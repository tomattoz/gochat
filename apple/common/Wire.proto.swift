/// Generated by the Protocol Buffers 3.5.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "wire.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct WireRoot {
    public static let `default` = WireRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class Contact : GeneratedMessage {
    public typealias BuilderType = Contact.Builder

    public static func == (lhs: Contact, rhs: Contact) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = fieldCheck && (lhs.hasOnline == rhs.hasOnline) && (!lhs.hasOnline || lhs.online == rhs.online)
        fieldCheck = fieldCheck && (lhs.hasDeviceToken == rhs.hasDeviceToken) && (!lhs.hasDeviceToken || lhs.deviceToken == rhs.deviceToken)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:String! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var name:String! = nil
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var online:Bool! = nil
    public fileprivate(set) var hasOnline:Bool = false

    public fileprivate(set) var deviceToken:String! = nil
    public fileprivate(set) var hasDeviceToken:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeString(fieldNumber: 1, value:id)
        }
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 2, value:name)
        }
        if hasOnline {
            try codedOutputStream.writeBool(fieldNumber: 3, value:online)
        }
        if hasDeviceToken {
            try codedOutputStream.writeString(fieldNumber: 4, value:deviceToken)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeStringSize(fieldNumber: 1)
        }
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 2)
        }
        if hasOnline {
            serialize_size += online.computeBoolSize(fieldNumber: 3)
        }
        if hasDeviceToken {
            serialize_size += deviceToken.computeStringSize(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Contact.Builder {
        return Contact.classBuilder() as! Contact.Builder
    }
    public func getBuilder() -> Contact.Builder {
        return classBuilder() as! Contact.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Contact.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Contact.Builder()
    }
    public func toBuilder() throws -> Contact.Builder {
        return try Contact.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Contact) throws -> Contact.Builder {
        return try Contact.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = id
        }
        if hasName {
            jsonMap["name"] = name
        }
        if hasOnline {
            jsonMap["online"] = online
        }
        if hasDeviceToken {
            jsonMap["deviceToken"] = deviceToken
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Contact {
        return try Contact.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Contact {
        return try Contact.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        if hasOnline {
            output += "\(indent) online: \(online) \n"
        }
        if hasDeviceToken {
            output += "\(indent) deviceToken: \(deviceToken) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasOnline {
                hashCode = (hashCode &* 31) &+ online.hashValue
            }
            if hasDeviceToken {
                hashCode = (hashCode &* 31) &+ deviceToken.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Contact"
    }
    override public func className() -> String {
        return "Contact"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Contact = Contact()
        public func getMessage() -> Contact {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:String {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:String) -> Contact.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Contact.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> Contact.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> Contact.Builder{
            builderResult.hasName = false
            builderResult.name = nil
            return self
        }
        public var online:Bool {
            get {
                return builderResult.online
            }
            set (value) {
                builderResult.hasOnline = true
                builderResult.online = value
            }
        }
        public var hasOnline:Bool {
            get {
                return builderResult.hasOnline
            }
        }
        @discardableResult
        public func setOnline(_ value:Bool) -> Contact.Builder {
            self.online = value
            return self
        }
        @discardableResult
        public func clearOnline() -> Contact.Builder{
            builderResult.hasOnline = false
            builderResult.online = nil
            return self
        }
        public var deviceToken:String {
            get {
                return builderResult.deviceToken
            }
            set (value) {
                builderResult.hasDeviceToken = true
                builderResult.deviceToken = value
            }
        }
        public var hasDeviceToken:Bool {
            get {
                return builderResult.hasDeviceToken
            }
        }
        @discardableResult
        public func setDeviceToken(_ value:String) -> Contact.Builder {
            self.deviceToken = value
            return self
        }
        @discardableResult
        public func clearDeviceToken() -> Contact.Builder{
            builderResult.hasDeviceToken = false
            builderResult.deviceToken = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Contact.Builder {
            builderResult = Contact()
            return self
        }
        override public func clone() throws -> Contact.Builder {
            return try Contact.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Contact {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Contact {
            let returnMe:Contact = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Contact) throws -> Contact.Builder {
            if other == Contact() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasName {
                name = other.name
            }
            if other.hasOnline {
                online = other.online
            }
            if other.hasDeviceToken {
                deviceToken = other.deviceToken
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Contact.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Contact.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    id = try codedInputStream.readString()

                case 18:
                    name = try codedInputStream.readString()

                case 24:
                    online = try codedInputStream.readBool()

                case 34:
                    deviceToken = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Contact.Builder {
            let resultDecodedBuilder = Contact.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = jsonValueId
            }
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            if let jsonValueOnline = jsonMap["online"] as? Bool {
                resultDecodedBuilder.online = jsonValueOnline
            }
            if let jsonValueDeviceToken = jsonMap["deviceToken"] as? String {
                resultDecodedBuilder.deviceToken = jsonValueDeviceToken
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Contact.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Contact.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Store : GeneratedMessage {
    public typealias BuilderType = Store.Builder

    public static func == (lhs: Store, rhs: Store) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var key:Data! = nil
    public fileprivate(set) var hasKey:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasKey {
            try codedOutputStream.writeData(fieldNumber: 1, value:key)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasKey {
            serialize_size += key.computeDataSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Store.Builder {
        return Store.classBuilder() as! Store.Builder
    }
    public func getBuilder() -> Store.Builder {
        return classBuilder() as! Store.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Store.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Store.Builder()
    }
    public func toBuilder() throws -> Store.Builder {
        return try Store.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Store) throws -> Store.Builder {
        return try Store.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasKey {
            jsonMap["key"] = key.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Store {
        return try Store.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Store {
        return try Store.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasKey {
            output += "\(indent) key: \(key) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasKey {
                hashCode = (hashCode &* 31) &+ key.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Store"
    }
    override public func className() -> String {
        return "Store"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Store = Store()
        public func getMessage() -> Store {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var key:Data {
            get {
                return builderResult.key
            }
            set (value) {
                builderResult.hasKey = true
                builderResult.key = value
            }
        }
        public var hasKey:Bool {
            get {
                return builderResult.hasKey
            }
        }
        @discardableResult
        public func setKey(_ value:Data) -> Store.Builder {
            self.key = value
            return self
        }
        @discardableResult
        public func clearKey() -> Store.Builder{
            builderResult.hasKey = false
            builderResult.key = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Store.Builder {
            builderResult = Store()
            return self
        }
        override public func clone() throws -> Store.Builder {
            return try Store.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Store {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Store {
            let returnMe:Store = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Store) throws -> Store.Builder {
            if other == Store() {
                return self
            }
            if other.hasKey {
                key = other.key
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Store.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Store.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    key = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Store.Builder {
            let resultDecodedBuilder = Store.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
                resultDecodedBuilder.key = Data(base64Encoded:jsonValueKey, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Store.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Store.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Login : GeneratedMessage {
    public typealias BuilderType = Login.Builder

    public static func == (lhs: Login, rhs: Login) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
        fieldCheck = fieldCheck && (lhs.hasUserName == rhs.hasUserName) && (!lhs.hasUserName || lhs.userName == rhs.userName)
        fieldCheck = fieldCheck && (lhs.hasAuthenToken == rhs.hasAuthenToken) && (!lhs.hasAuthenToken || lhs.authenToken == rhs.authenToken)
        fieldCheck = fieldCheck && (lhs.hasDeviceToken == rhs.hasDeviceToken) && (!lhs.hasDeviceToken || lhs.deviceToken == rhs.deviceToken)
        fieldCheck = fieldCheck && (lhs.hasPlatform == rhs.hasPlatform) && (!lhs.hasPlatform || lhs.platform == rhs.platform)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var type:UInt32! = nil
    public fileprivate(set) var hasType:Bool = false

    public fileprivate(set) var userName:String! = nil
    public fileprivate(set) var hasUserName:Bool = false

    public fileprivate(set) var authenToken:String! = nil
    public fileprivate(set) var hasAuthenToken:Bool = false

    public fileprivate(set) var deviceToken:String! = nil
    public fileprivate(set) var hasDeviceToken:Bool = false

    public fileprivate(set) var platform:String! = nil
    public fileprivate(set) var hasPlatform:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasType {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:type)
        }
        if hasUserName {
            try codedOutputStream.writeString(fieldNumber: 2, value:userName)
        }
        if hasAuthenToken {
            try codedOutputStream.writeString(fieldNumber: 3, value:authenToken)
        }
        if hasDeviceToken {
            try codedOutputStream.writeString(fieldNumber: 4, value:deviceToken)
        }
        if hasPlatform {
            try codedOutputStream.writeString(fieldNumber: 5, value:platform)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasType {
            serialize_size += type.computeUInt32Size(fieldNumber: 1)
        }
        if hasUserName {
            serialize_size += userName.computeStringSize(fieldNumber: 2)
        }
        if hasAuthenToken {
            serialize_size += authenToken.computeStringSize(fieldNumber: 3)
        }
        if hasDeviceToken {
            serialize_size += deviceToken.computeStringSize(fieldNumber: 4)
        }
        if hasPlatform {
            serialize_size += platform.computeStringSize(fieldNumber: 5)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Login.Builder {
        return Login.classBuilder() as! Login.Builder
    }
    public func getBuilder() -> Login.Builder {
        return classBuilder() as! Login.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Login.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Login.Builder()
    }
    public func toBuilder() throws -> Login.Builder {
        return try Login.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Login) throws -> Login.Builder {
        return try Login.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasType {
            jsonMap["type"] = UInt(type)
        }
        if hasUserName {
            jsonMap["userName"] = userName
        }
        if hasAuthenToken {
            jsonMap["authenToken"] = authenToken
        }
        if hasDeviceToken {
            jsonMap["deviceToken"] = deviceToken
        }
        if hasPlatform {
            jsonMap["platform"] = platform
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Login {
        return try Login.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Login {
        return try Login.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasType {
            output += "\(indent) type: \(type) \n"
        }
        if hasUserName {
            output += "\(indent) userName: \(userName) \n"
        }
        if hasAuthenToken {
            output += "\(indent) authenToken: \(authenToken) \n"
        }
        if hasDeviceToken {
            output += "\(indent) deviceToken: \(deviceToken) \n"
        }
        if hasPlatform {
            output += "\(indent) platform: \(platform) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasType {
                hashCode = (hashCode &* 31) &+ type.hashValue
            }
            if hasUserName {
                hashCode = (hashCode &* 31) &+ userName.hashValue
            }
            if hasAuthenToken {
                hashCode = (hashCode &* 31) &+ authenToken.hashValue
            }
            if hasDeviceToken {
                hashCode = (hashCode &* 31) &+ deviceToken.hashValue
            }
            if hasPlatform {
                hashCode = (hashCode &* 31) &+ platform.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Login"
    }
    override public func className() -> String {
        return "Login"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Login = Login()
        public func getMessage() -> Login {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var type:UInt32 {
            get {
                return builderResult.type
            }
            set (value) {
                builderResult.hasType = true
                builderResult.type = value
            }
        }
        public var hasType:Bool {
            get {
                return builderResult.hasType
            }
        }
        @discardableResult
        public func setType(_ value:UInt32) -> Login.Builder {
            self.type = value
            return self
        }
        @discardableResult
        public func clearType() -> Login.Builder{
            builderResult.hasType = false
            builderResult.type = nil
            return self
        }
        public var userName:String {
            get {
                return builderResult.userName
            }
            set (value) {
                builderResult.hasUserName = true
                builderResult.userName = value
            }
        }
        public var hasUserName:Bool {
            get {
                return builderResult.hasUserName
            }
        }
        @discardableResult
        public func setUserName(_ value:String) -> Login.Builder {
            self.userName = value
            return self
        }
        @discardableResult
        public func clearUserName() -> Login.Builder{
            builderResult.hasUserName = false
            builderResult.userName = nil
            return self
        }
        public var authenToken:String {
            get {
                return builderResult.authenToken
            }
            set (value) {
                builderResult.hasAuthenToken = true
                builderResult.authenToken = value
            }
        }
        public var hasAuthenToken:Bool {
            get {
                return builderResult.hasAuthenToken
            }
        }
        @discardableResult
        public func setAuthenToken(_ value:String) -> Login.Builder {
            self.authenToken = value
            return self
        }
        @discardableResult
        public func clearAuthenToken() -> Login.Builder{
            builderResult.hasAuthenToken = false
            builderResult.authenToken = nil
            return self
        }
        public var deviceToken:String {
            get {
                return builderResult.deviceToken
            }
            set (value) {
                builderResult.hasDeviceToken = true
                builderResult.deviceToken = value
            }
        }
        public var hasDeviceToken:Bool {
            get {
                return builderResult.hasDeviceToken
            }
        }
        @discardableResult
        public func setDeviceToken(_ value:String) -> Login.Builder {
            self.deviceToken = value
            return self
        }
        @discardableResult
        public func clearDeviceToken() -> Login.Builder{
            builderResult.hasDeviceToken = false
            builderResult.deviceToken = nil
            return self
        }
        public var platform:String {
            get {
                return builderResult.platform
            }
            set (value) {
                builderResult.hasPlatform = true
                builderResult.platform = value
            }
        }
        public var hasPlatform:Bool {
            get {
                return builderResult.hasPlatform
            }
        }
        @discardableResult
        public func setPlatform(_ value:String) -> Login.Builder {
            self.platform = value
            return self
        }
        @discardableResult
        public func clearPlatform() -> Login.Builder{
            builderResult.hasPlatform = false
            builderResult.platform = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Login.Builder {
            builderResult = Login()
            return self
        }
        override public func clone() throws -> Login.Builder {
            return try Login.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Login {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Login {
            let returnMe:Login = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Login) throws -> Login.Builder {
            if other == Login() {
                return self
            }
            if other.hasType {
                type = other.type
            }
            if other.hasUserName {
                userName = other.userName
            }
            if other.hasAuthenToken {
                authenToken = other.authenToken
            }
            if other.hasDeviceToken {
                deviceToken = other.deviceToken
            }
            if other.hasPlatform {
                platform = other.platform
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Login.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Login.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    type = try codedInputStream.readUInt32()

                case 18:
                    userName = try codedInputStream.readString()

                case 26:
                    authenToken = try codedInputStream.readString()

                case 34:
                    deviceToken = try codedInputStream.readString()

                case 42:
                    platform = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Login.Builder {
            let resultDecodedBuilder = Login.Builder()
            if let jsonValueType = jsonMap["type"] as? UInt {
                resultDecodedBuilder.type = UInt32(jsonValueType)
            } else if let jsonValueType = jsonMap["type"] as? String {
                resultDecodedBuilder.type = UInt32(jsonValueType)!
            }
            if let jsonValueUserName = jsonMap["userName"] as? String {
                resultDecodedBuilder.userName = jsonValueUserName
            }
            if let jsonValueAuthenToken = jsonMap["authenToken"] as? String {
                resultDecodedBuilder.authenToken = jsonValueAuthenToken
            }
            if let jsonValueDeviceToken = jsonMap["deviceToken"] as? String {
                resultDecodedBuilder.deviceToken = jsonValueDeviceToken
            }
            if let jsonValuePlatform = jsonMap["platform"] as? String {
                resultDecodedBuilder.platform = jsonValuePlatform
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Login.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Login.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class PlainText : GeneratedMessage {
    public typealias BuilderType = PlainText.Builder

    public static func == (lhs: PlainText, rhs: PlainText) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
        fieldCheck = fieldCheck && (lhs.hasContent == rhs.hasContent) && (!lhs.hasContent || lhs.content == rhs.content)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var type:UInt32! = nil
    public fileprivate(set) var hasType:Bool = false

    public fileprivate(set) var content:String! = nil
    public fileprivate(set) var hasContent:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasType {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:type)
        }
        if hasContent {
            try codedOutputStream.writeString(fieldNumber: 2, value:content)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasType {
            serialize_size += type.computeUInt32Size(fieldNumber: 1)
        }
        if hasContent {
            serialize_size += content.computeStringSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> PlainText.Builder {
        return PlainText.classBuilder() as! PlainText.Builder
    }
    public func getBuilder() -> PlainText.Builder {
        return classBuilder() as! PlainText.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PlainText.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return PlainText.Builder()
    }
    public func toBuilder() throws -> PlainText.Builder {
        return try PlainText.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:PlainText) throws -> PlainText.Builder {
        return try PlainText.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasType {
            jsonMap["type"] = UInt(type)
        }
        if hasContent {
            jsonMap["content"] = content
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> PlainText {
        return try PlainText.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> PlainText {
        return try PlainText.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasType {
            output += "\(indent) type: \(type) \n"
        }
        if hasContent {
            output += "\(indent) content: \(content) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasType {
                hashCode = (hashCode &* 31) &+ type.hashValue
            }
            if hasContent {
                hashCode = (hashCode &* 31) &+ content.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "PlainText"
    }
    override public func className() -> String {
        return "PlainText"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:PlainText = PlainText()
        public func getMessage() -> PlainText {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var type:UInt32 {
            get {
                return builderResult.type
            }
            set (value) {
                builderResult.hasType = true
                builderResult.type = value
            }
        }
        public var hasType:Bool {
            get {
                return builderResult.hasType
            }
        }
        @discardableResult
        public func setType(_ value:UInt32) -> PlainText.Builder {
            self.type = value
            return self
        }
        @discardableResult
        public func clearType() -> PlainText.Builder{
            builderResult.hasType = false
            builderResult.type = nil
            return self
        }
        public var content:String {
            get {
                return builderResult.content
            }
            set (value) {
                builderResult.hasContent = true
                builderResult.content = value
            }
        }
        public var hasContent:Bool {
            get {
                return builderResult.hasContent
            }
        }
        @discardableResult
        public func setContent(_ value:String) -> PlainText.Builder {
            self.content = value
            return self
        }
        @discardableResult
        public func clearContent() -> PlainText.Builder{
            builderResult.hasContent = false
            builderResult.content = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> PlainText.Builder {
            builderResult = PlainText()
            return self
        }
        override public func clone() throws -> PlainText.Builder {
            return try PlainText.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> PlainText {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> PlainText {
            let returnMe:PlainText = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:PlainText) throws -> PlainText.Builder {
            if other == PlainText() {
                return self
            }
            if other.hasType {
                type = other.type
            }
            if other.hasContent {
                content = other.content
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> PlainText.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PlainText.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    type = try codedInputStream.readUInt32()

                case 18:
                    content = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> PlainText.Builder {
            let resultDecodedBuilder = PlainText.Builder()
            if let jsonValueType = jsonMap["type"] as? UInt {
                resultDecodedBuilder.type = UInt32(jsonValueType)
            } else if let jsonValueType = jsonMap["type"] as? String {
                resultDecodedBuilder.type = UInt32(jsonValueType)!
            }
            if let jsonValueContent = jsonMap["content"] as? String {
                resultDecodedBuilder.content = jsonValueContent
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> PlainText.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try PlainText.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Wire : GeneratedMessage {
    public typealias BuilderType = Wire.Builder

    public static func == (lhs: Wire, rhs: Wire) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
        fieldCheck = fieldCheck && (lhs.hasFrom == rhs.hasFrom) && (!lhs.hasFrom || lhs.from == rhs.from)
        fieldCheck = fieldCheck && (lhs.hasTo == rhs.hasTo) && (!lhs.hasTo || lhs.to == rhs.to)
        fieldCheck = fieldCheck && (lhs.hasWhich == rhs.hasWhich) && (!lhs.hasWhich || lhs.which == rhs.which)
        fieldCheck = fieldCheck && (lhs.hasLogin == rhs.hasLogin) && (!lhs.hasLogin || lhs.login == rhs.login)
        fieldCheck = fieldCheck && (lhs.contacts == rhs.contacts)
        fieldCheck = fieldCheck && (lhs.hasStore == rhs.hasStore) && (!lhs.hasStore || lhs.store == rhs.store)
        fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
        fieldCheck = fieldCheck && (lhs.hasPlainText == rhs.hasPlainText) && (!lhs.hasPlainText || lhs.plainText == rhs.plainText)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



        //Enum type declaration start 

        /// Identifies which field is filled in
        public enum Which:Int32, GeneratedEnum {
            case login = 0
            case contacts = 1
            case presence = 2
            case store = 3
            case load = 4
            case publicKey = 5
            case publicKeyResponse = 6
            case handshake = 7
            case payload = 8
            case loginResponse = 9
            case plainText = 10
            public func toString() -> String {
                switch self {
                case .login: return "LOGIN"
                case .contacts: return "CONTACTS"
                case .presence: return "PRESENCE"
                case .store: return "STORE"
                case .load: return "LOAD"
                case .publicKey: return "PUBLIC_KEY"
                case .publicKeyResponse: return "PUBLIC_KEY_RESPONSE"
                case .handshake: return "HANDSHAKE"
                case .payload: return "PAYLOAD"
                case .loginResponse: return "LOGIN_RESPONSE"
                case .plainText: return "PLAIN_TEXT"
                }
            }
            public static func fromString(_ str:String) throws -> Wire.Which {
                switch str {
                case "LOGIN":    return .login
                case "CONTACTS":    return .contacts
                case "PRESENCE":    return .presence
                case "STORE":    return .store
                case "LOAD":    return .load
                case "PUBLIC_KEY":    return .publicKey
                case "PUBLIC_KEY_RESPONSE":    return .publicKeyResponse
                case "HANDSHAKE":    return .handshake
                case "PAYLOAD":    return .payload
                case "LOGIN_RESPONSE":    return .loginResponse
                case "PLAIN_TEXT":    return .plainText
                default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                }
            }
            public var debugDescription:String { return getDescription() }
            public var description:String { return getDescription() }
            private func getDescription() -> String { 
                switch self {
                case .login: return ".login"
                case .contacts: return ".contacts"
                case .presence: return ".presence"
                case .store: return ".store"
                case .load: return ".load"
                case .publicKey: return ".publicKey"
                case .publicKeyResponse: return ".publicKeyResponse"
                case .handshake: return ".handshake"
                case .payload: return ".payload"
                case .loginResponse: return ".loginResponse"
                case .plainText: return ".plainText"
                }
            }
            public var hashValue:Int {
                return self.rawValue.hashValue
            }
            public static func ==(lhs:Which, rhs:Which) -> Bool {
                return lhs.hashValue == rhs.hashValue
            }
        }

        //Enum type declaration end 

    public fileprivate(set) var version:UInt32! = nil
    public fileprivate(set) var hasVersion:Bool = false

    public fileprivate(set) var sessionId:String! = nil
    public fileprivate(set) var hasSessionId:Bool = false

    public fileprivate(set) var from:String! = nil
    public fileprivate(set) var hasFrom:Bool = false

    public fileprivate(set) var to:String! = nil
    public fileprivate(set) var hasTo:Bool = false

    public fileprivate(set) var which:Wire.Which = Wire.Which.login
    public fileprivate(set) var hasWhich:Bool = false
    public fileprivate(set) var login:Login!
    public fileprivate(set) var hasLogin:Bool = false
    public fileprivate(set) var contacts:Array<Contact>  = Array<Contact>()
    public fileprivate(set) var store:Store!
    public fileprivate(set) var hasStore:Bool = false
    public fileprivate(set) var payload:Data! = nil
    public fileprivate(set) var hasPayload:Bool = false

    public fileprivate(set) var plainText:PlainText!
    public fileprivate(set) var hasPlainText:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasVersion {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:version)
        }
        if hasSessionId {
            try codedOutputStream.writeString(fieldNumber: 2, value:sessionId)
        }
        if hasFrom {
            try codedOutputStream.writeString(fieldNumber: 3, value:from)
        }
        if hasTo {
            try codedOutputStream.writeString(fieldNumber: 4, value:to)
        }
        if hasWhich {
            try codedOutputStream.writeEnum(fieldNumber: 5, value:which.rawValue)
        }
        if hasLogin {
            try codedOutputStream.writeMessage(fieldNumber: 101, value:login)
        }
        for oneElementContacts in contacts {
              try codedOutputStream.writeMessage(fieldNumber: 102, value:oneElementContacts)
        }
        if hasStore {
            try codedOutputStream.writeMessage(fieldNumber: 104, value:store)
        }
        if hasPayload {
            try codedOutputStream.writeData(fieldNumber: 106, value:payload)
        }
        if hasPlainText {
            try codedOutputStream.writeMessage(fieldNumber: 107, value:plainText)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasVersion {
            serialize_size += version.computeUInt32Size(fieldNumber: 1)
        }
        if hasSessionId {
            serialize_size += sessionId.computeStringSize(fieldNumber: 2)
        }
        if hasFrom {
            serialize_size += from.computeStringSize(fieldNumber: 3)
        }
        if hasTo {
            serialize_size += to.computeStringSize(fieldNumber: 4)
        }
        if (hasWhich) {
            serialize_size += which.rawValue.computeEnumSize(fieldNumber: 5)
        }
        if hasLogin {
            if let varSizelogin = login?.computeMessageSize(fieldNumber: 101) {
                serialize_size += varSizelogin
            }
        }
        for oneElementContacts in contacts {
            serialize_size += oneElementContacts.computeMessageSize(fieldNumber: 102)
        }
        if hasStore {
            if let varSizestore = store?.computeMessageSize(fieldNumber: 104) {
                serialize_size += varSizestore
            }
        }
        if hasPayload {
            serialize_size += payload.computeDataSize(fieldNumber: 106)
        }
        if hasPlainText {
            if let varSizeplainText = plainText?.computeMessageSize(fieldNumber: 107) {
                serialize_size += varSizeplainText
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Wire.Builder {
        return Wire.classBuilder() as! Wire.Builder
    }
    public func getBuilder() -> Wire.Builder {
        return classBuilder() as! Wire.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Wire.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Wire.Builder()
    }
    public func toBuilder() throws -> Wire.Builder {
        return try Wire.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Wire) throws -> Wire.Builder {
        return try Wire.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasVersion {
            jsonMap["version"] = UInt(version)
        }
        if hasSessionId {
            jsonMap["sessionId"] = sessionId
        }
        if hasFrom {
            jsonMap["from"] = from
        }
        if hasTo {
            jsonMap["to"] = to
        }
        if hasWhich {
            jsonMap["which"] = which.toString()
        }
        if hasLogin {
            jsonMap["login"] = try login.encode()
        }
        if !contacts.isEmpty {
            var jsonArrayContacts:Array<Dictionary<String,Any>> = []
            for oneValueContacts in contacts {
                let ecodedMessageContacts = try oneValueContacts.encode()
                jsonArrayContacts.append(ecodedMessageContacts)
            }
            jsonMap["contacts"] = jsonArrayContacts
        }
        if hasStore {
            jsonMap["store"] = try store.encode()
        }
        if hasPayload {
            jsonMap["payload"] = payload.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        if hasPlainText {
            jsonMap["plainText"] = try plainText.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Wire {
        return try Wire.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Wire {
        return try Wire.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasVersion {
            output += "\(indent) version: \(version) \n"
        }
        if hasSessionId {
            output += "\(indent) sessionId: \(sessionId) \n"
        }
        if hasFrom {
            output += "\(indent) from: \(from) \n"
        }
        if hasTo {
            output += "\(indent) to: \(to) \n"
        }
        if (hasWhich) {
            output += "\(indent) which: \(which.description)\n"
        }
        if hasLogin {
            output += "\(indent) login {\n"
            if let outDescLogin = login {
                output += try outDescLogin.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        var contactsElementIndex:Int = 0
        for oneElementContacts in contacts {
            output += "\(indent) contacts[\(contactsElementIndex)] {\n"
            output += try oneElementContacts.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            contactsElementIndex += 1
        }
        if hasStore {
            output += "\(indent) store {\n"
            if let outDescStore = store {
                output += try outDescStore.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasPayload {
            output += "\(indent) payload: \(payload) \n"
        }
        if hasPlainText {
            output += "\(indent) plainText {\n"
            if let outDescPlainText = plainText {
                output += try outDescPlainText.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasSessionId {
                hashCode = (hashCode &* 31) &+ sessionId.hashValue
            }
            if hasFrom {
                hashCode = (hashCode &* 31) &+ from.hashValue
            }
            if hasTo {
                hashCode = (hashCode &* 31) &+ to.hashValue
            }
            if hasWhich {
                 hashCode = (hashCode &* 31) &+ which.hashValue
            }
            if hasLogin {
                if let hashValuelogin = login?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuelogin
                }
            }
            for oneElementContacts in contacts {
                hashCode = (hashCode &* 31) &+ oneElementContacts.hashValue
            }
            if hasStore {
                if let hashValuestore = store?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuestore
                }
            }
            if hasPayload {
                hashCode = (hashCode &* 31) &+ payload.hashValue
            }
            if hasPlainText {
                if let hashValueplainText = plainText?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplainText
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Wire"
    }
    override public func className() -> String {
        return "Wire"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Wire = Wire()
        public func getMessage() -> Wire {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var version:UInt32 {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:UInt32) -> Wire.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> Wire.Builder{
            builderResult.hasVersion = false
            builderResult.version = nil
            return self
        }
        public var sessionId:String {
            get {
                return builderResult.sessionId
            }
            set (value) {
                builderResult.hasSessionId = true
                builderResult.sessionId = value
            }
        }
        public var hasSessionId:Bool {
            get {
                return builderResult.hasSessionId
            }
        }
        @discardableResult
        public func setSessionId(_ value:String) -> Wire.Builder {
            self.sessionId = value
            return self
        }
        @discardableResult
        public func clearSessionId() -> Wire.Builder{
            builderResult.hasSessionId = false
            builderResult.sessionId = nil
            return self
        }
        public var from:String {
            get {
                return builderResult.from
            }
            set (value) {
                builderResult.hasFrom = true
                builderResult.from = value
            }
        }
        public var hasFrom:Bool {
            get {
                return builderResult.hasFrom
            }
        }
        @discardableResult
        public func setFrom(_ value:String) -> Wire.Builder {
            self.from = value
            return self
        }
        @discardableResult
        public func clearFrom() -> Wire.Builder{
            builderResult.hasFrom = false
            builderResult.from = nil
            return self
        }
        public var to:String {
            get {
                return builderResult.to
            }
            set (value) {
                builderResult.hasTo = true
                builderResult.to = value
            }
        }
        public var hasTo:Bool {
            get {
                return builderResult.hasTo
            }
        }
        @discardableResult
        public func setTo(_ value:String) -> Wire.Builder {
            self.to = value
            return self
        }
        @discardableResult
        public func clearTo() -> Wire.Builder{
            builderResult.hasTo = false
            builderResult.to = nil
            return self
        }
            public var which:Wire.Which {
                get {
                    return builderResult.which
                }
                set (value) {
                    builderResult.hasWhich = true
                    builderResult.which = value
                }
            }
            public var hasWhich:Bool{
                get {
                    return builderResult.hasWhich
                }
            }
        @discardableResult
            public func setWhich(_ value:Wire.Which) -> Wire.Builder {
              self.which = value
              return self
            }
        @discardableResult
            public func clearWhich() -> Wire.Builder {
               builderResult.hasWhich = false
               builderResult.which = .login
               return self
            }
        /// One of the following will be filled in
        public var login:Login! {
            get {
                if loginBuilder_ != nil {
                    builderResult.login = loginBuilder_.getMessage()
                }
                return builderResult.login
            }
            set (value) {
                builderResult.hasLogin = value != nil
                builderResult.login = value
            }
        }
        public var hasLogin:Bool {
            get {
                return builderResult.hasLogin
            }
        }
        fileprivate var loginBuilder_:Login.Builder! {
            didSet {
                builderResult.hasLogin = true
            }
        }
        public func getLoginBuilder() -> Login.Builder {
            if loginBuilder_ == nil {
                loginBuilder_ = Login.Builder()
                builderResult.login = loginBuilder_.getMessage()
                if login != nil {
                    try! loginBuilder_.mergeFrom(other: login)
                }
            }
            return loginBuilder_
        }
        @discardableResult
        public func setLogin(_ value:Login!) -> Wire.Builder {
            self.login = value
            return self
        }
        @discardableResult
        public func mergeLogin(value:Login) throws -> Wire.Builder {
            if builderResult.hasLogin {
                builderResult.login = try Login.builderWithPrototype(prototype:builderResult.login).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.login = value
            }
            builderResult.hasLogin = true
            return self
        }
        @discardableResult
        public func clearLogin() -> Wire.Builder {
            loginBuilder_ = nil
            builderResult.hasLogin = false
            builderResult.login = nil
            return self
        }
        /// for roster, presence, and invite
        public var contacts:Array<Contact> {
            get {
                return builderResult.contacts
            }
            set (value) {
                builderResult.contacts = value
            }
        }
        @discardableResult
        public func setContacts(_ value:Array<Contact>) -> Wire.Builder {
            self.contacts = value
            return self
        }
        @discardableResult
        public func clearContacts() -> Wire.Builder {
            builderResult.contacts.removeAll(keepingCapacity: false)
            return self
        }
        public var store:Store! {
            get {
                if storeBuilder_ != nil {
                    builderResult.store = storeBuilder_.getMessage()
                }
                return builderResult.store
            }
            set (value) {
                builderResult.hasStore = value != nil
                builderResult.store = value
            }
        }
        public var hasStore:Bool {
            get {
                return builderResult.hasStore
            }
        }
        fileprivate var storeBuilder_:Store.Builder! {
            didSet {
                builderResult.hasStore = true
            }
        }
        public func getStoreBuilder() -> Store.Builder {
            if storeBuilder_ == nil {
                storeBuilder_ = Store.Builder()
                builderResult.store = storeBuilder_.getMessage()
                if store != nil {
                    try! storeBuilder_.mergeFrom(other: store)
                }
            }
            return storeBuilder_
        }
        @discardableResult
        public func setStore(_ value:Store!) -> Wire.Builder {
            self.store = value
            return self
        }
        @discardableResult
        public func mergeStore(value:Store) throws -> Wire.Builder {
            if builderResult.hasStore {
                builderResult.store = try Store.builderWithPrototype(prototype:builderResult.store).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.store = value
            }
            builderResult.hasStore = true
            return self
        }
        @discardableResult
        public func clearStore() -> Wire.Builder {
            storeBuilder_ = nil
            builderResult.hasStore = false
            builderResult.store = nil
            return self
        }
        public var payload:Data {
            get {
                return builderResult.payload
            }
            set (value) {
                builderResult.hasPayload = true
                builderResult.payload = value
            }
        }
        public var hasPayload:Bool {
            get {
                return builderResult.hasPayload
            }
        }
        @discardableResult
        public func setPayload(_ value:Data) -> Wire.Builder {
            self.payload = value
            return self
        }
        @discardableResult
        public func clearPayload() -> Wire.Builder{
            builderResult.hasPayload = false
            builderResult.payload = nil
            return self
        }
        public var plainText:PlainText! {
            get {
                if plainTextBuilder_ != nil {
                    builderResult.plainText = plainTextBuilder_.getMessage()
                }
                return builderResult.plainText
            }
            set (value) {
                builderResult.hasPlainText = value != nil
                builderResult.plainText = value
            }
        }
        public var hasPlainText:Bool {
            get {
                return builderResult.hasPlainText
            }
        }
        fileprivate var plainTextBuilder_:PlainText.Builder! {
            didSet {
                builderResult.hasPlainText = true
            }
        }
        public func getPlainTextBuilder() -> PlainText.Builder {
            if plainTextBuilder_ == nil {
                plainTextBuilder_ = PlainText.Builder()
                builderResult.plainText = plainTextBuilder_.getMessage()
                if plainText != nil {
                    try! plainTextBuilder_.mergeFrom(other: plainText)
                }
            }
            return plainTextBuilder_
        }
        @discardableResult
        public func setPlainText(_ value:PlainText!) -> Wire.Builder {
            self.plainText = value
            return self
        }
        @discardableResult
        public func mergePlainText(value:PlainText) throws -> Wire.Builder {
            if builderResult.hasPlainText {
                builderResult.plainText = try PlainText.builderWithPrototype(prototype:builderResult.plainText).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.plainText = value
            }
            builderResult.hasPlainText = true
            return self
        }
        @discardableResult
        public func clearPlainText() -> Wire.Builder {
            plainTextBuilder_ = nil
            builderResult.hasPlainText = false
            builderResult.plainText = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Wire.Builder {
            builderResult = Wire()
            return self
        }
        override public func clone() throws -> Wire.Builder {
            return try Wire.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Wire {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Wire {
            let returnMe:Wire = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Wire) throws -> Wire.Builder {
            if other == Wire() {
                return self
            }
            if other.hasVersion {
                version = other.version
            }
            if other.hasSessionId {
                sessionId = other.sessionId
            }
            if other.hasFrom {
                from = other.from
            }
            if other.hasTo {
                to = other.to
            }
            if other.hasWhich {
                which = other.which
            }
            if (other.hasLogin) {
                try mergeLogin(value: other.login)
            }
            if !other.contacts.isEmpty  {
                 builderResult.contacts += other.contacts
            }
            if (other.hasStore) {
                try mergeStore(value: other.store)
            }
            if other.hasPayload {
                payload = other.payload
            }
            if (other.hasPlainText) {
                try mergePlainText(value: other.plainText)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Wire.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Wire.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    version = try codedInputStream.readUInt32()

                case 18:
                    sessionId = try codedInputStream.readString()

                case 26:
                    from = try codedInputStream.readString()

                case 34:
                    to = try codedInputStream.readString()

                case 40:
                    let valueIntwhich = try codedInputStream.readEnum()
                    if let enumswhich = Wire.Which(rawValue:valueIntwhich){
                        which = enumswhich
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueIntwhich))
                    }

                case 810:
                    let subBuilder:Login.Builder = Login.Builder()
                    if hasLogin {
                        try subBuilder.mergeFrom(other: login)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    login = subBuilder.buildPartial()

                case 818:
                    let subBuilder = Contact.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    contacts.append(subBuilder.buildPartial())

                case 834:
                    let subBuilder:Store.Builder = Store.Builder()
                    if hasStore {
                        try subBuilder.mergeFrom(other: store)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    store = subBuilder.buildPartial()

                case 850:
                    payload = try codedInputStream.readData()

                case 858:
                    let subBuilder:PlainText.Builder = PlainText.Builder()
                    if hasPlainText {
                        try subBuilder.mergeFrom(other: plainText)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    plainText = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Wire.Builder {
            let resultDecodedBuilder = Wire.Builder()
            if let jsonValueVersion = jsonMap["version"] as? UInt {
                resultDecodedBuilder.version = UInt32(jsonValueVersion)
            } else if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = UInt32(jsonValueVersion)!
            }
            if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                resultDecodedBuilder.sessionId = jsonValueSessionId
            }
            if let jsonValueFrom = jsonMap["from"] as? String {
                resultDecodedBuilder.from = jsonValueFrom
            }
            if let jsonValueTo = jsonMap["to"] as? String {
                resultDecodedBuilder.to = jsonValueTo
            }
            if let jsonValueWhich = jsonMap["which"] as? String {
                resultDecodedBuilder.which = try Wire.Which.fromString(jsonValueWhich)
            }
            if let jsonValueLogin = jsonMap["login"] as? Dictionary<String,Any> {
                resultDecodedBuilder.login = try Login.Builder.decodeToBuilder(jsonMap:jsonValueLogin).build()

            }
            if let jsonValueContacts = jsonMap["contacts"] as? Array<Dictionary<String,Any>> {
                var jsonArrayContacts:Array<Contact> = []
                for oneValueContacts in jsonValueContacts {
                    let messageFromStringContacts = try Contact.Builder.decodeToBuilder(jsonMap:oneValueContacts).build()

                    jsonArrayContacts.append(messageFromStringContacts)
                }
                resultDecodedBuilder.contacts = jsonArrayContacts
            }
            if let jsonValueStore = jsonMap["store"] as? Dictionary<String,Any> {
                resultDecodedBuilder.store = try Store.Builder.decodeToBuilder(jsonMap:jsonValueStore).build()

            }
            if let jsonValuePayload = jsonMap["payload"] as? String {
                resultDecodedBuilder.payload = Data(base64Encoded:jsonValuePayload, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            if let jsonValuePlainText = jsonMap["plainText"] as? Dictionary<String,Any> {
                resultDecodedBuilder.plainText = try PlainText.Builder.decodeToBuilder(jsonMap:jsonValuePlainText).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Wire.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Wire.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension Contact: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Contact> {
        var mergedArray = Array<Contact>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Contact? {
        return try Contact.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Contact {
        return try Contact.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Contact {
        return try Contact.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Contact {
        return try Contact.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Contact {
        return try Contact.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Contact {
        return try Contact.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Contact {
        return try Contact.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "name": return self.name
        case "online": return self.online
        case "deviceToken": return self.deviceToken
        default: return nil
        }
    }
}
extension Contact.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Contact
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "name": return self.name
            case "online": return self.online
            case "deviceToken": return self.deviceToken
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.id = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "online":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.online = newSubscriptValue
            case "deviceToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.deviceToken = newSubscriptValue
            default: return
            }
        }
    }
}
extension Store: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Store> {
        var mergedArray = Array<Store>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Store? {
        return try Store.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Store {
        return try Store.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Store {
        return try Store.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Store {
        return try Store.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Store {
        return try Store.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Store {
        return try Store.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Store {
        return try Store.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        default: return nil
        }
    }
}
extension Store.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Store
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.key = newSubscriptValue
            default: return
            }
        }
    }
}
extension Login: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Login> {
        var mergedArray = Array<Login>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Login? {
        return try Login.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Login {
        return try Login.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Login {
        return try Login.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Login {
        return try Login.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Login {
        return try Login.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Login {
        return try Login.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Login {
        return try Login.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "type": return self.type
        case "userName": return self.userName
        case "authenToken": return self.authenToken
        case "deviceToken": return self.deviceToken
        case "platform": return self.platform
        default: return nil
        }
    }
}
extension Login.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Login
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "type": return self.type
            case "userName": return self.userName
            case "authenToken": return self.authenToken
            case "deviceToken": return self.deviceToken
            case "platform": return self.platform
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.type = newSubscriptValue
            case "userName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userName = newSubscriptValue
            case "authenToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.authenToken = newSubscriptValue
            case "deviceToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.deviceToken = newSubscriptValue
            case "platform":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.platform = newSubscriptValue
            default: return
            }
        }
    }
}
extension PlainText: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<PlainText> {
        var mergedArray = Array<PlainText>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> PlainText? {
        return try PlainText.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> PlainText {
        return try PlainText.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> PlainText {
        return try PlainText.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> PlainText {
        return try PlainText.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> PlainText {
        return try PlainText.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> PlainText {
        return try PlainText.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PlainText {
        return try PlainText.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "type": return self.type
        case "content": return self.content
        default: return nil
        }
    }
}
extension PlainText.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = PlainText
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "type": return self.type
            case "content": return self.content
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.type = newSubscriptValue
            case "content":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.content = newSubscriptValue
            default: return
            }
        }
    }
}
extension Wire: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Wire> {
        var mergedArray = Array<Wire>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Wire? {
        return try Wire.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Wire {
        return try Wire.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Wire {
        return try Wire.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Wire {
        return try Wire.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Wire {
        return try Wire.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Wire {
        return try Wire.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Wire {
        return try Wire.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "version": return self.version
        case "sessionId": return self.sessionId
        case "from": return self.from
        case "to": return self.to
        case "which": return self.which
        case "login": return self.login
        case "contacts": return self.contacts
        case "store": return self.store
        case "payload": return self.payload
        case "plainText": return self.plainText
        default: return nil
        }
    }
}
extension Wire.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Wire
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "version": return self.version
            case "sessionId": return self.sessionId
            case "from": return self.from
            case "to": return self.to
            case "which": return self.which
            case "login": return self.login
            case "contacts": return self.contacts
            case "store": return self.store
            case "payload": return self.payload
            case "plainText": return self.plainText
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.version = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "from":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.from = newSubscriptValue
            case "to":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.to = newSubscriptValue
            case "which":
                guard let newSubscriptValue = newSubscriptValue as? Wire.Which else {
                    return
                }
                self.which = newSubscriptValue
            case "login":
                guard let newSubscriptValue = newSubscriptValue as? Login else {
                    return
                }
                self.login = newSubscriptValue
            case "contacts":
                guard let newSubscriptValue = newSubscriptValue as? Array<Contact> else {
                    return
                }
                self.contacts = newSubscriptValue
            case "store":
                guard let newSubscriptValue = newSubscriptValue as? Store else {
                    return
                }
                self.store = newSubscriptValue
            case "payload":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.payload = newSubscriptValue
            case "plainText":
                guard let newSubscriptValue = newSubscriptValue as? PlainText else {
                    return
                }
                self.plainText = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
