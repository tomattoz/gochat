/// Generated by the Protocol Buffers 3.5.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "voip.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct VoipRoot {
    public static let `default` = VoipRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class Text : GeneratedMessage {
    public typealias BuilderType = Text.Builder

    public static func == (lhs: Text, rhs: Text) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasFrom == rhs.hasFrom) && (!lhs.hasFrom || lhs.from == rhs.from)
        fieldCheck = fieldCheck && (lhs.hasTo == rhs.hasTo) && (!lhs.hasTo || lhs.to == rhs.to)
        fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var from:String! = nil
    public fileprivate(set) var hasFrom:Bool = false

    public fileprivate(set) var to:String! = nil
    public fileprivate(set) var hasTo:Bool = false

    public fileprivate(set) var body:Data! = nil
    public fileprivate(set) var hasBody:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasFrom {
            try codedOutputStream.writeString(fieldNumber: 1, value:from)
        }
        if hasTo {
            try codedOutputStream.writeString(fieldNumber: 2, value:to)
        }
        if hasBody {
            try codedOutputStream.writeData(fieldNumber: 3, value:body)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasFrom {
            serialize_size += from.computeStringSize(fieldNumber: 1)
        }
        if hasTo {
            serialize_size += to.computeStringSize(fieldNumber: 2)
        }
        if hasBody {
            serialize_size += body.computeDataSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Text.Builder {
        return Text.classBuilder() as! Text.Builder
    }
    public func getBuilder() -> Text.Builder {
        return classBuilder() as! Text.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Text.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Text.Builder()
    }
    public func toBuilder() throws -> Text.Builder {
        return try Text.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Text) throws -> Text.Builder {
        return try Text.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasFrom {
            jsonMap["from"] = from
        }
        if hasTo {
            jsonMap["to"] = to
        }
        if hasBody {
            jsonMap["body"] = body.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Text {
        return try Text.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Text {
        return try Text.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasFrom {
            output += "\(indent) from: \(from) \n"
        }
        if hasTo {
            output += "\(indent) to: \(to) \n"
        }
        if hasBody {
            output += "\(indent) body: \(body) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasFrom {
                hashCode = (hashCode &* 31) &+ from.hashValue
            }
            if hasTo {
                hashCode = (hashCode &* 31) &+ to.hashValue
            }
            if hasBody {
                hashCode = (hashCode &* 31) &+ body.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Text"
    }
    override public func className() -> String {
        return "Text"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Text = Text()
        public func getMessage() -> Text {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var from:String {
            get {
                return builderResult.from
            }
            set (value) {
                builderResult.hasFrom = true
                builderResult.from = value
            }
        }
        public var hasFrom:Bool {
            get {
                return builderResult.hasFrom
            }
        }
        @discardableResult
        public func setFrom(_ value:String) -> Text.Builder {
            self.from = value
            return self
        }
        @discardableResult
        public func clearFrom() -> Text.Builder{
            builderResult.hasFrom = false
            builderResult.from = nil
            return self
        }
        public var to:String {
            get {
                return builderResult.to
            }
            set (value) {
                builderResult.hasTo = true
                builderResult.to = value
            }
        }
        public var hasTo:Bool {
            get {
                return builderResult.hasTo
            }
        }
        @discardableResult
        public func setTo(_ value:String) -> Text.Builder {
            self.to = value
            return self
        }
        @discardableResult
        public func clearTo() -> Text.Builder{
            builderResult.hasTo = false
            builderResult.to = nil
            return self
        }
        public var body:Data {
            get {
                return builderResult.body
            }
            set (value) {
                builderResult.hasBody = true
                builderResult.body = value
            }
        }
        public var hasBody:Bool {
            get {
                return builderResult.hasBody
            }
        }
        @discardableResult
        public func setBody(_ value:Data) -> Text.Builder {
            self.body = value
            return self
        }
        @discardableResult
        public func clearBody() -> Text.Builder{
            builderResult.hasBody = false
            builderResult.body = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Text.Builder {
            builderResult = Text()
            return self
        }
        override public func clone() throws -> Text.Builder {
            return try Text.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Text {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Text {
            let returnMe:Text = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Text) throws -> Text.Builder {
            if other == Text() {
                return self
            }
            if other.hasFrom {
                from = other.from
            }
            if other.hasTo {
                to = other.to
            }
            if other.hasBody {
                body = other.body
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Text.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Text.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    from = try codedInputStream.readString()

                case 18:
                    to = try codedInputStream.readString()

                case 26:
                    body = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Text.Builder {
            let resultDecodedBuilder = Text.Builder()
            if let jsonValueFrom = jsonMap["from"] as? String {
                resultDecodedBuilder.from = jsonValueFrom
            }
            if let jsonValueTo = jsonMap["to"] as? String {
                resultDecodedBuilder.to = jsonValueTo
            }
            if let jsonValueBody = jsonMap["body"] as? String {
                resultDecodedBuilder.body = Data(base64Encoded:jsonValueBody, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Text.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Text.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class File : GeneratedMessage {
    public typealias BuilderType = File.Builder

    public static func == (lhs: File, rhs: File) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasSequence == rhs.hasSequence) && (!lhs.hasSequence || lhs.sequence == rhs.sequence)
        fieldCheck = fieldCheck && (lhs.hasTotalSize == rhs.hasTotalSize) && (!lhs.hasTotalSize || lhs.totalSize == rhs.totalSize)
        fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var sequence:UInt64! = nil
    public fileprivate(set) var hasSequence:Bool = false

    public fileprivate(set) var totalSize:UInt64! = nil
    public fileprivate(set) var hasTotalSize:Bool = false

    public fileprivate(set) var body:Data! = nil
    public fileprivate(set) var hasBody:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasSequence {
            try codedOutputStream.writeUInt64(fieldNumber: 1, value:sequence)
        }
        if hasTotalSize {
            try codedOutputStream.writeUInt64(fieldNumber: 2, value:totalSize)
        }
        if hasBody {
            try codedOutputStream.writeData(fieldNumber: 3, value:body)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSequence {
            serialize_size += sequence.computeUInt64Size(fieldNumber: 1)
        }
        if hasTotalSize {
            serialize_size += totalSize.computeUInt64Size(fieldNumber: 2)
        }
        if hasBody {
            serialize_size += body.computeDataSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> File.Builder {
        return File.classBuilder() as! File.Builder
    }
    public func getBuilder() -> File.Builder {
        return classBuilder() as! File.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return File.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return File.Builder()
    }
    public func toBuilder() throws -> File.Builder {
        return try File.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:File) throws -> File.Builder {
        return try File.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasSequence {
            jsonMap["sequence"] = "\(sequence!)"
        }
        if hasTotalSize {
            jsonMap["totalSize"] = "\(totalSize!)"
        }
        if hasBody {
            jsonMap["body"] = body.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> File {
        return try File.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> File {
        return try File.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasSequence {
            output += "\(indent) sequence: \(sequence) \n"
        }
        if hasTotalSize {
            output += "\(indent) totalSize: \(totalSize) \n"
        }
        if hasBody {
            output += "\(indent) body: \(body) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSequence {
                hashCode = (hashCode &* 31) &+ sequence.hashValue
            }
            if hasTotalSize {
                hashCode = (hashCode &* 31) &+ totalSize.hashValue
            }
            if hasBody {
                hashCode = (hashCode &* 31) &+ body.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "File"
    }
    override public func className() -> String {
        return "File"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:File = File()
        public func getMessage() -> File {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var sequence:UInt64 {
            get {
                return builderResult.sequence
            }
            set (value) {
                builderResult.hasSequence = true
                builderResult.sequence = value
            }
        }
        public var hasSequence:Bool {
            get {
                return builderResult.hasSequence
            }
        }
        @discardableResult
        public func setSequence(_ value:UInt64) -> File.Builder {
            self.sequence = value
            return self
        }
        @discardableResult
        public func clearSequence() -> File.Builder{
            builderResult.hasSequence = false
            builderResult.sequence = nil
            return self
        }
        public var totalSize:UInt64 {
            get {
                return builderResult.totalSize
            }
            set (value) {
                builderResult.hasTotalSize = true
                builderResult.totalSize = value
            }
        }
        public var hasTotalSize:Bool {
            get {
                return builderResult.hasTotalSize
            }
        }
        @discardableResult
        public func setTotalSize(_ value:UInt64) -> File.Builder {
            self.totalSize = value
            return self
        }
        @discardableResult
        public func clearTotalSize() -> File.Builder{
            builderResult.hasTotalSize = false
            builderResult.totalSize = nil
            return self
        }
        public var body:Data {
            get {
                return builderResult.body
            }
            set (value) {
                builderResult.hasBody = true
                builderResult.body = value
            }
        }
        public var hasBody:Bool {
            get {
                return builderResult.hasBody
            }
        }
        @discardableResult
        public func setBody(_ value:Data) -> File.Builder {
            self.body = value
            return self
        }
        @discardableResult
        public func clearBody() -> File.Builder{
            builderResult.hasBody = false
            builderResult.body = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> File.Builder {
            builderResult = File()
            return self
        }
        override public func clone() throws -> File.Builder {
            return try File.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> File {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> File {
            let returnMe:File = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:File) throws -> File.Builder {
            if other == File() {
                return self
            }
            if other.hasSequence {
                sequence = other.sequence
            }
            if other.hasTotalSize {
                totalSize = other.totalSize
            }
            if other.hasBody {
                body = other.body
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> File.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> File.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    sequence = try codedInputStream.readUInt64()

                case 16:
                    totalSize = try codedInputStream.readUInt64()

                case 26:
                    body = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> File.Builder {
            let resultDecodedBuilder = File.Builder()
            if let jsonValueSequence = jsonMap["sequence"] as? String {
                resultDecodedBuilder.sequence = UInt64(jsonValueSequence)!
            } else if let jsonValueSequence = jsonMap["sequence"] as? UInt {
                resultDecodedBuilder.sequence = UInt64(jsonValueSequence)
            }
            if let jsonValueTotalSize = jsonMap["totalSize"] as? String {
                resultDecodedBuilder.totalSize = UInt64(jsonValueTotalSize)!
            } else if let jsonValueTotalSize = jsonMap["totalSize"] as? UInt {
                resultDecodedBuilder.totalSize = UInt64(jsonValueTotalSize)
            }
            if let jsonValueBody = jsonMap["body"] as? String {
                resultDecodedBuilder.body = Data(base64Encoded:jsonValueBody, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> File.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try File.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Call : GeneratedMessage {
    public typealias BuilderType = Call.Builder

    public static func == (lhs: Call, rhs: Call) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
        fieldCheck = fieldCheck && (lhs.hasTo == rhs.hasTo) && (!lhs.hasTo || lhs.to == rhs.to)
        fieldCheck = fieldCheck && (lhs.hasFrom == rhs.hasFrom) && (!lhs.hasFrom || lhs.from == rhs.from)
        fieldCheck = fieldCheck && (lhs.hasAudio == rhs.hasAudio) && (!lhs.hasAudio || lhs.audio == rhs.audio)
        fieldCheck = fieldCheck && (lhs.hasVideo == rhs.hasVideo) && (!lhs.hasVideo || lhs.video == rhs.video)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var key:String! = nil
    public fileprivate(set) var hasKey:Bool = false

    public fileprivate(set) var to:String! = nil
    public fileprivate(set) var hasTo:Bool = false

    public fileprivate(set) var from:String! = nil
    public fileprivate(set) var hasFrom:Bool = false

    public fileprivate(set) var audio:Bool! = nil
    public fileprivate(set) var hasAudio:Bool = false

    public fileprivate(set) var video:Bool! = nil
    public fileprivate(set) var hasVideo:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasKey {
            try codedOutputStream.writeString(fieldNumber: 1, value:key)
        }
        if hasTo {
            try codedOutputStream.writeString(fieldNumber: 2, value:to)
        }
        if hasFrom {
            try codedOutputStream.writeString(fieldNumber: 3, value:from)
        }
        if hasAudio {
            try codedOutputStream.writeBool(fieldNumber: 4, value:audio)
        }
        if hasVideo {
            try codedOutputStream.writeBool(fieldNumber: 5, value:video)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasKey {
            serialize_size += key.computeStringSize(fieldNumber: 1)
        }
        if hasTo {
            serialize_size += to.computeStringSize(fieldNumber: 2)
        }
        if hasFrom {
            serialize_size += from.computeStringSize(fieldNumber: 3)
        }
        if hasAudio {
            serialize_size += audio.computeBoolSize(fieldNumber: 4)
        }
        if hasVideo {
            serialize_size += video.computeBoolSize(fieldNumber: 5)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Call.Builder {
        return Call.classBuilder() as! Call.Builder
    }
    public func getBuilder() -> Call.Builder {
        return classBuilder() as! Call.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Call.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Call.Builder()
    }
    public func toBuilder() throws -> Call.Builder {
        return try Call.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Call) throws -> Call.Builder {
        return try Call.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasKey {
            jsonMap["key"] = key
        }
        if hasTo {
            jsonMap["to"] = to
        }
        if hasFrom {
            jsonMap["from"] = from
        }
        if hasAudio {
            jsonMap["audio"] = audio
        }
        if hasVideo {
            jsonMap["video"] = video
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Call {
        return try Call.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Call {
        return try Call.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasKey {
            output += "\(indent) key: \(key) \n"
        }
        if hasTo {
            output += "\(indent) to: \(to) \n"
        }
        if hasFrom {
            output += "\(indent) from: \(from) \n"
        }
        if hasAudio {
            output += "\(indent) audio: \(audio) \n"
        }
        if hasVideo {
            output += "\(indent) video: \(video) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasKey {
                hashCode = (hashCode &* 31) &+ key.hashValue
            }
            if hasTo {
                hashCode = (hashCode &* 31) &+ to.hashValue
            }
            if hasFrom {
                hashCode = (hashCode &* 31) &+ from.hashValue
            }
            if hasAudio {
                hashCode = (hashCode &* 31) &+ audio.hashValue
            }
            if hasVideo {
                hashCode = (hashCode &* 31) &+ video.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Call"
    }
    override public func className() -> String {
        return "Call"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Call = Call()
        public func getMessage() -> Call {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var key:String {
            get {
                return builderResult.key
            }
            set (value) {
                builderResult.hasKey = true
                builderResult.key = value
            }
        }
        public var hasKey:Bool {
            get {
                return builderResult.hasKey
            }
        }
        @discardableResult
        public func setKey(_ value:String) -> Call.Builder {
            self.key = value
            return self
        }
        @discardableResult
        public func clearKey() -> Call.Builder{
            builderResult.hasKey = false
            builderResult.key = nil
            return self
        }
        public var to:String {
            get {
                return builderResult.to
            }
            set (value) {
                builderResult.hasTo = true
                builderResult.to = value
            }
        }
        public var hasTo:Bool {
            get {
                return builderResult.hasTo
            }
        }
        @discardableResult
        public func setTo(_ value:String) -> Call.Builder {
            self.to = value
            return self
        }
        @discardableResult
        public func clearTo() -> Call.Builder{
            builderResult.hasTo = false
            builderResult.to = nil
            return self
        }
        public var from:String {
            get {
                return builderResult.from
            }
            set (value) {
                builderResult.hasFrom = true
                builderResult.from = value
            }
        }
        public var hasFrom:Bool {
            get {
                return builderResult.hasFrom
            }
        }
        @discardableResult
        public func setFrom(_ value:String) -> Call.Builder {
            self.from = value
            return self
        }
        @discardableResult
        public func clearFrom() -> Call.Builder{
            builderResult.hasFrom = false
            builderResult.from = nil
            return self
        }
        public var audio:Bool {
            get {
                return builderResult.audio
            }
            set (value) {
                builderResult.hasAudio = true
                builderResult.audio = value
            }
        }
        public var hasAudio:Bool {
            get {
                return builderResult.hasAudio
            }
        }
        @discardableResult
        public func setAudio(_ value:Bool) -> Call.Builder {
            self.audio = value
            return self
        }
        @discardableResult
        public func clearAudio() -> Call.Builder{
            builderResult.hasAudio = false
            builderResult.audio = nil
            return self
        }
        public var video:Bool {
            get {
                return builderResult.video
            }
            set (value) {
                builderResult.hasVideo = true
                builderResult.video = value
            }
        }
        public var hasVideo:Bool {
            get {
                return builderResult.hasVideo
            }
        }
        @discardableResult
        public func setVideo(_ value:Bool) -> Call.Builder {
            self.video = value
            return self
        }
        @discardableResult
        public func clearVideo() -> Call.Builder{
            builderResult.hasVideo = false
            builderResult.video = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Call.Builder {
            builderResult = Call()
            return self
        }
        override public func clone() throws -> Call.Builder {
            return try Call.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Call {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Call {
            let returnMe:Call = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Call) throws -> Call.Builder {
            if other == Call() {
                return self
            }
            if other.hasKey {
                key = other.key
            }
            if other.hasTo {
                to = other.to
            }
            if other.hasFrom {
                from = other.from
            }
            if other.hasAudio {
                audio = other.audio
            }
            if other.hasVideo {
                video = other.video
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Call.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Call.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    key = try codedInputStream.readString()

                case 18:
                    to = try codedInputStream.readString()

                case 26:
                    from = try codedInputStream.readString()

                case 32:
                    audio = try codedInputStream.readBool()

                case 40:
                    video = try codedInputStream.readBool()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Call.Builder {
            let resultDecodedBuilder = Call.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
                resultDecodedBuilder.key = jsonValueKey
            }
            if let jsonValueTo = jsonMap["to"] as? String {
                resultDecodedBuilder.to = jsonValueTo
            }
            if let jsonValueFrom = jsonMap["from"] as? String {
                resultDecodedBuilder.from = jsonValueFrom
            }
            if let jsonValueAudio = jsonMap["audio"] as? Bool {
                resultDecodedBuilder.audio = jsonValueAudio
            }
            if let jsonValueVideo = jsonMap["video"] as? Bool {
                resultDecodedBuilder.video = jsonValueVideo
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Call.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Call.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Time : GeneratedMessage {
    public typealias BuilderType = Time.Builder

    public static func == (lhs: Time, rhs: Time) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
        fieldCheck = fieldCheck && (lhs.hasScale == rhs.hasScale) && (!lhs.hasScale || lhs.scale == rhs.scale)
        fieldCheck = fieldCheck && (lhs.hasFlags == rhs.hasFlags) && (!lhs.hasFlags || lhs.flags == rhs.flags)
        fieldCheck = fieldCheck && (lhs.hasEpoch == rhs.hasEpoch) && (!lhs.hasEpoch || lhs.epoch == rhs.epoch)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var value:Int64! = nil
    public fileprivate(set) var hasValue:Bool = false

    public fileprivate(set) var scale:Int32! = nil
    public fileprivate(set) var hasScale:Bool = false

    public fileprivate(set) var flags:UInt32! = nil
    public fileprivate(set) var hasFlags:Bool = false

    public fileprivate(set) var epoch:Int64! = nil
    public fileprivate(set) var hasEpoch:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasValue {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:value)
        }
        if hasScale {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:scale)
        }
        if hasFlags {
            try codedOutputStream.writeUInt32(fieldNumber: 3, value:flags)
        }
        if hasEpoch {
            try codedOutputStream.writeInt64(fieldNumber: 4, value:epoch)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasValue {
            serialize_size += value.computeInt64Size(fieldNumber: 1)
        }
        if hasScale {
            serialize_size += scale.computeInt32Size(fieldNumber: 2)
        }
        if hasFlags {
            serialize_size += flags.computeUInt32Size(fieldNumber: 3)
        }
        if hasEpoch {
            serialize_size += epoch.computeInt64Size(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Time.Builder {
        return Time.classBuilder() as! Time.Builder
    }
    public func getBuilder() -> Time.Builder {
        return classBuilder() as! Time.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Time.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Time.Builder()
    }
    public func toBuilder() throws -> Time.Builder {
        return try Time.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Time) throws -> Time.Builder {
        return try Time.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasValue {
            jsonMap["value"] = "\(value!)"
        }
        if hasScale {
            jsonMap["scale"] = Int(scale)
        }
        if hasFlags {
            jsonMap["flags"] = UInt(flags)
        }
        if hasEpoch {
            jsonMap["epoch"] = "\(epoch!)"
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Time {
        return try Time.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Time {
        return try Time.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasValue {
            output += "\(indent) value: \(value) \n"
        }
        if hasScale {
            output += "\(indent) scale: \(scale) \n"
        }
        if hasFlags {
            output += "\(indent) flags: \(flags) \n"
        }
        if hasEpoch {
            output += "\(indent) epoch: \(epoch) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasValue {
                hashCode = (hashCode &* 31) &+ value.hashValue
            }
            if hasScale {
                hashCode = (hashCode &* 31) &+ scale.hashValue
            }
            if hasFlags {
                hashCode = (hashCode &* 31) &+ flags.hashValue
            }
            if hasEpoch {
                hashCode = (hashCode &* 31) &+ epoch.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Time"
    }
    override public func className() -> String {
        return "Time"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Time = Time()
        public func getMessage() -> Time {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var value:Int64 {
            get {
                return builderResult.value
            }
            set (value) {
                builderResult.hasValue = true
                builderResult.value = value
            }
        }
        public var hasValue:Bool {
            get {
                return builderResult.hasValue
            }
        }
        @discardableResult
        public func setValue(_ value:Int64) -> Time.Builder {
            self.value = value
            return self
        }
        @discardableResult
        public func clearValue() -> Time.Builder{
            builderResult.hasValue = false
            builderResult.value = nil
            return self
        }
        public var scale:Int32 {
            get {
                return builderResult.scale
            }
            set (value) {
                builderResult.hasScale = true
                builderResult.scale = value
            }
        }
        public var hasScale:Bool {
            get {
                return builderResult.hasScale
            }
        }
        @discardableResult
        public func setScale(_ value:Int32) -> Time.Builder {
            self.scale = value
            return self
        }
        @discardableResult
        public func clearScale() -> Time.Builder{
            builderResult.hasScale = false
            builderResult.scale = nil
            return self
        }
        public var flags:UInt32 {
            get {
                return builderResult.flags
            }
            set (value) {
                builderResult.hasFlags = true
                builderResult.flags = value
            }
        }
        public var hasFlags:Bool {
            get {
                return builderResult.hasFlags
            }
        }
        @discardableResult
        public func setFlags(_ value:UInt32) -> Time.Builder {
            self.flags = value
            return self
        }
        @discardableResult
        public func clearFlags() -> Time.Builder{
            builderResult.hasFlags = false
            builderResult.flags = nil
            return self
        }
        public var epoch:Int64 {
            get {
                return builderResult.epoch
            }
            set (value) {
                builderResult.hasEpoch = true
                builderResult.epoch = value
            }
        }
        public var hasEpoch:Bool {
            get {
                return builderResult.hasEpoch
            }
        }
        @discardableResult
        public func setEpoch(_ value:Int64) -> Time.Builder {
            self.epoch = value
            return self
        }
        @discardableResult
        public func clearEpoch() -> Time.Builder{
            builderResult.hasEpoch = false
            builderResult.epoch = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Time.Builder {
            builderResult = Time()
            return self
        }
        override public func clone() throws -> Time.Builder {
            return try Time.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Time {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Time {
            let returnMe:Time = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Time) throws -> Time.Builder {
            if other == Time() {
                return self
            }
            if other.hasValue {
                value = other.value
            }
            if other.hasScale {
                scale = other.scale
            }
            if other.hasFlags {
                flags = other.flags
            }
            if other.hasEpoch {
                epoch = other.epoch
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Time.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Time.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    value = try codedInputStream.readInt64()

                case 16:
                    scale = try codedInputStream.readInt32()

                case 24:
                    flags = try codedInputStream.readUInt32()

                case 32:
                    epoch = try codedInputStream.readInt64()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Time.Builder {
            let resultDecodedBuilder = Time.Builder()
            if let jsonValueValue = jsonMap["value"] as? String {
                resultDecodedBuilder.value = Int64(jsonValueValue)!
            } else if let jsonValueValue = jsonMap["value"] as? Int {
                resultDecodedBuilder.value = Int64(jsonValueValue)
            }
            if let jsonValueScale = jsonMap["scale"] as? Int {
                resultDecodedBuilder.scale = Int32(jsonValueScale)
            } else if let jsonValueScale = jsonMap["scale"] as? String {
                resultDecodedBuilder.scale = Int32(jsonValueScale)!
            }
            if let jsonValueFlags = jsonMap["flags"] as? UInt {
                resultDecodedBuilder.flags = UInt32(jsonValueFlags)
            } else if let jsonValueFlags = jsonMap["flags"] as? String {
                resultDecodedBuilder.flags = UInt32(jsonValueFlags)!
            }
            if let jsonValueEpoch = jsonMap["epoch"] as? String {
                resultDecodedBuilder.epoch = Int64(jsonValueEpoch)!
            } else if let jsonValueEpoch = jsonMap["epoch"] as? Int {
                resultDecodedBuilder.epoch = Int64(jsonValueEpoch)
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Time.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Time.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Timestamp : GeneratedMessage {
    public typealias BuilderType = Timestamp.Builder

    public static func == (lhs: Timestamp, rhs: Timestamp) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasDuration == rhs.hasDuration) && (!lhs.hasDuration || lhs.duration == rhs.duration)
        fieldCheck = fieldCheck && (lhs.hasPresentation == rhs.hasPresentation) && (!lhs.hasPresentation || lhs.presentation == rhs.presentation)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var duration:Time!
    public fileprivate(set) var hasDuration:Bool = false
    public fileprivate(set) var presentation:Time!
    public fileprivate(set) var hasPresentation:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasDuration {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:duration)
        }
        if hasPresentation {
            try codedOutputStream.writeMessage(fieldNumber: 2, value:presentation)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasDuration {
            if let varSizeduration = duration?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizeduration
            }
        }
        if hasPresentation {
            if let varSizepresentation = presentation?.computeMessageSize(fieldNumber: 2) {
                serialize_size += varSizepresentation
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Timestamp.Builder {
        return Timestamp.classBuilder() as! Timestamp.Builder
    }
    public func getBuilder() -> Timestamp.Builder {
        return classBuilder() as! Timestamp.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Timestamp.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Timestamp.Builder()
    }
    public func toBuilder() throws -> Timestamp.Builder {
        return try Timestamp.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Timestamp) throws -> Timestamp.Builder {
        return try Timestamp.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasDuration {
            jsonMap["duration"] = try duration.encode()
        }
        if hasPresentation {
            jsonMap["presentation"] = try presentation.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Timestamp {
        return try Timestamp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Timestamp {
        return try Timestamp.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasDuration {
            output += "\(indent) duration {\n"
            if let outDescDuration = duration {
                output += try outDescDuration.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasPresentation {
            output += "\(indent) presentation {\n"
            if let outDescPresentation = presentation {
                output += try outDescPresentation.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDuration {
                if let hashValueduration = duration?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueduration
                }
            }
            if hasPresentation {
                if let hashValuepresentation = presentation?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepresentation
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Timestamp"
    }
    override public func className() -> String {
        return "Timestamp"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Timestamp = Timestamp()
        public func getMessage() -> Timestamp {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var duration:Time! {
            get {
                if durationBuilder_ != nil {
                    builderResult.duration = durationBuilder_.getMessage()
                }
                return builderResult.duration
            }
            set (value) {
                builderResult.hasDuration = value != nil
                builderResult.duration = value
            }
        }
        public var hasDuration:Bool {
            get {
                return builderResult.hasDuration
            }
        }
        fileprivate var durationBuilder_:Time.Builder! {
            didSet {
                builderResult.hasDuration = true
            }
        }
        public func getDurationBuilder() -> Time.Builder {
            if durationBuilder_ == nil {
                durationBuilder_ = Time.Builder()
                builderResult.duration = durationBuilder_.getMessage()
                if duration != nil {
                    try! durationBuilder_.mergeFrom(other: duration)
                }
            }
            return durationBuilder_
        }
        @discardableResult
        public func setDuration(_ value:Time!) -> Timestamp.Builder {
            self.duration = value
            return self
        }
        @discardableResult
        public func mergeDuration(value:Time) throws -> Timestamp.Builder {
            if builderResult.hasDuration {
                builderResult.duration = try Time.builderWithPrototype(prototype:builderResult.duration).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.duration = value
            }
            builderResult.hasDuration = true
            return self
        }
        @discardableResult
        public func clearDuration() -> Timestamp.Builder {
            durationBuilder_ = nil
            builderResult.hasDuration = false
            builderResult.duration = nil
            return self
        }
        public var presentation:Time! {
            get {
                if presentationBuilder_ != nil {
                    builderResult.presentation = presentationBuilder_.getMessage()
                }
                return builderResult.presentation
            }
            set (value) {
                builderResult.hasPresentation = value != nil
                builderResult.presentation = value
            }
        }
        public var hasPresentation:Bool {
            get {
                return builderResult.hasPresentation
            }
        }
        fileprivate var presentationBuilder_:Time.Builder! {
            didSet {
                builderResult.hasPresentation = true
            }
        }
        public func getPresentationBuilder() -> Time.Builder {
            if presentationBuilder_ == nil {
                presentationBuilder_ = Time.Builder()
                builderResult.presentation = presentationBuilder_.getMessage()
                if presentation != nil {
                    try! presentationBuilder_.mergeFrom(other: presentation)
                }
            }
            return presentationBuilder_
        }
        @discardableResult
        public func setPresentation(_ value:Time!) -> Timestamp.Builder {
            self.presentation = value
            return self
        }
        @discardableResult
        public func mergePresentation(value:Time) throws -> Timestamp.Builder {
            if builderResult.hasPresentation {
                builderResult.presentation = try Time.builderWithPrototype(prototype:builderResult.presentation).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.presentation = value
            }
            builderResult.hasPresentation = true
            return self
        }
        @discardableResult
        public func clearPresentation() -> Timestamp.Builder {
            presentationBuilder_ = nil
            builderResult.hasPresentation = false
            builderResult.presentation = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Timestamp.Builder {
            builderResult = Timestamp()
            return self
        }
        override public func clone() throws -> Timestamp.Builder {
            return try Timestamp.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Timestamp {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Timestamp {
            let returnMe:Timestamp = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Timestamp) throws -> Timestamp.Builder {
            if other == Timestamp() {
                return self
            }
            if (other.hasDuration) {
                try mergeDuration(value: other.duration)
            }
            if (other.hasPresentation) {
                try mergePresentation(value: other.presentation)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Timestamp.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Timestamp.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:Time.Builder = Time.Builder()
                    if hasDuration {
                        try subBuilder.mergeFrom(other: duration)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    duration = subBuilder.buildPartial()

                case 18:
                    let subBuilder:Time.Builder = Time.Builder()
                    if hasPresentation {
                        try subBuilder.mergeFrom(other: presentation)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    presentation = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Timestamp.Builder {
            let resultDecodedBuilder = Timestamp.Builder()
            if let jsonValueDuration = jsonMap["duration"] as? Dictionary<String,Any> {
                resultDecodedBuilder.duration = try Time.Builder.decodeToBuilder(jsonMap:jsonValueDuration).build()

            }
            if let jsonValuePresentation = jsonMap["presentation"] as? Dictionary<String,Any> {
                resultDecodedBuilder.presentation = try Time.Builder.decodeToBuilder(jsonMap:jsonValuePresentation).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Timestamp.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Timestamp.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Image : GeneratedMessage {
    public typealias BuilderType = Image.Builder

    public static func == (lhs: Image, rhs: Image) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasWidth == rhs.hasWidth) && (!lhs.hasWidth || lhs.width == rhs.width)
        fieldCheck = fieldCheck && (lhs.hasHeight == rhs.hasHeight) && (!lhs.hasHeight || lhs.height == rhs.height)
        fieldCheck = fieldCheck && (lhs.hasFormat == rhs.hasFormat) && (!lhs.hasFormat || lhs.format == rhs.format)
        fieldCheck = fieldCheck && (lhs.hasAttachments == rhs.hasAttachments) && (!lhs.hasAttachments || lhs.attachments == rhs.attachments)
        fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



    //Nested type declaration start

    final public class AttachmentsEntry : GeneratedMessage {
        public typealias BuilderType = Image.AttachmentsEntry.Builder

        public static func == (lhs: Image.AttachmentsEntry, rhs: Image.AttachmentsEntry) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
            fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var key:String! = nil
        public fileprivate(set) var hasKey:Bool = false

        public fileprivate(set) var value:String! = nil
        public fileprivate(set) var hasValue:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasKey {
                try codedOutputStream.writeString(fieldNumber: 1, value:key)
            }
            if hasValue {
                try codedOutputStream.writeString(fieldNumber: 2, value:value)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasKey {
                serialize_size += key.computeStringSize(fieldNumber: 1)
            }
            if hasValue {
                serialize_size += value.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Image.AttachmentsEntry.Builder {
            return Image.AttachmentsEntry.classBuilder() as! Image.AttachmentsEntry.Builder
        }
        public func getBuilder() -> Image.AttachmentsEntry.Builder {
            return classBuilder() as! Image.AttachmentsEntry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Image.AttachmentsEntry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Image.AttachmentsEntry.Builder()
        }
        public func toBuilder() throws -> Image.AttachmentsEntry.Builder {
            return try Image.AttachmentsEntry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Image.AttachmentsEntry) throws -> Image.AttachmentsEntry.Builder {
            return try Image.AttachmentsEntry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasKey {
                jsonMap["key"] = key
            }
            if hasValue {
                jsonMap["value"] = value
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Image.AttachmentsEntry {
            return try Image.AttachmentsEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Image.AttachmentsEntry {
            return try Image.AttachmentsEntry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasKey {
                output += "\(indent) key: \(key) \n"
            }
            if hasValue {
                output += "\(indent) value: \(value) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                    hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                    hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Image.AttachmentsEntry"
        }
        override public func className() -> String {
            return "Image.AttachmentsEntry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Image.AttachmentsEntry = Image.AttachmentsEntry()
            public func getMessage() -> Image.AttachmentsEntry {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var key:String {
                get {
                    return builderResult.key
                }
                set (value) {
                    builderResult.hasKey = true
                    builderResult.key = value
                }
            }
            public var hasKey:Bool {
                get {
                    return builderResult.hasKey
                }
            }
            @discardableResult
            public func setKey(_ value:String) -> Image.AttachmentsEntry.Builder {
                self.key = value
                return self
            }
            @discardableResult
            public func clearKey() -> Image.AttachmentsEntry.Builder{
                builderResult.hasKey = false
                builderResult.key = nil
                return self
            }
            public var value:String {
                get {
                    return builderResult.value
                }
                set (value) {
                    builderResult.hasValue = true
                    builderResult.value = value
                }
            }
            public var hasValue:Bool {
                get {
                    return builderResult.hasValue
                }
            }
            @discardableResult
            public func setValue(_ value:String) -> Image.AttachmentsEntry.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> Image.AttachmentsEntry.Builder{
                builderResult.hasValue = false
                builderResult.value = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Image.AttachmentsEntry.Builder {
                builderResult = Image.AttachmentsEntry()
                return self
            }
            override public func clone() throws -> Image.AttachmentsEntry.Builder {
                return try Image.AttachmentsEntry.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Image.AttachmentsEntry {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Image.AttachmentsEntry {
                let returnMe:Image.AttachmentsEntry = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Image.AttachmentsEntry) throws -> Image.AttachmentsEntry.Builder {
                if other == Image.AttachmentsEntry() {
                    return self
                }
                if other.hasKey {
                    key = other.key
                }
                if other.hasValue {
                    value = other.value
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Image.AttachmentsEntry.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Image.AttachmentsEntry.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        key = try codedInputStream.readString()

                    case 18:
                        value = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Image.AttachmentsEntry.Builder {
                let resultDecodedBuilder = Image.AttachmentsEntry.Builder()
                if let jsonValueKey = jsonMap["key"] as? String {
                    resultDecodedBuilder.key = jsonValueKey
                }
                if let jsonValueValue = jsonMap["value"] as? String {
                    resultDecodedBuilder.value = jsonValueValue
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Image.AttachmentsEntry.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Image.AttachmentsEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    //Nested type declaration end

    public fileprivate(set) var width:Int64! = nil
    public fileprivate(set) var hasWidth:Bool = false

    public fileprivate(set) var height:Int64! = nil
    public fileprivate(set) var hasHeight:Bool = false

    public fileprivate(set) var format:UInt32! = nil
    public fileprivate(set) var hasFormat:Bool = false

    public fileprivate(set) var attachments:Dictionary<String,String> = Dictionary<String,String>()

    public fileprivate(set) var hasAttachments:Bool = false
    public fileprivate(set) var data:Data! = nil
    public fileprivate(set) var hasData:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasWidth {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:width)
        }
        if hasHeight {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:height)
        }
        if hasFormat {
            try codedOutputStream.writeUInt32(fieldNumber: 3, value:format)
        }
        if hasAttachments {
            for (keyAttachments, valueAttachments) in attachments {
                let valueOfAttachments = try! Image.AttachmentsEntry.Builder().setKey(keyAttachments).setValue(valueAttachments).build()
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:valueOfAttachments)
              }
        }
        if hasData {
            try codedOutputStream.writeData(fieldNumber: 5, value:data)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasWidth {
            serialize_size += width.computeInt64Size(fieldNumber: 1)
        }
        if hasHeight {
            serialize_size += height.computeInt64Size(fieldNumber: 2)
        }
        if hasFormat {
            serialize_size += format.computeUInt32Size(fieldNumber: 3)
        }
        if hasAttachments {
              for (keyAttachments, valueAttachments) in attachments {
                  let valueOfAttachments = try! Image.AttachmentsEntry.Builder().setKey(keyAttachments).setValue(valueAttachments).build()
            serialize_size += valueOfAttachments.computeMessageSize(fieldNumber: 4)
            }
        }
        if hasData {
            serialize_size += data.computeDataSize(fieldNumber: 5)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Image.Builder {
        return Image.classBuilder() as! Image.Builder
    }
    public func getBuilder() -> Image.Builder {
        return classBuilder() as! Image.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Image.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Image.Builder()
    }
    public func toBuilder() throws -> Image.Builder {
        return try Image.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Image) throws -> Image.Builder {
        return try Image.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasWidth {
            jsonMap["width"] = "\(width!)"
        }
        if hasHeight {
            jsonMap["height"] = "\(height!)"
        }
        if hasFormat {
            jsonMap["format"] = UInt(format)
        }
        if hasAttachments {
            var mapAttachments = Dictionary<String, String>()
            for (keyAttachments, valueAttachments) in attachments {
                mapAttachments["\(keyAttachments)"] = valueAttachments
            }
            jsonMap["attachments"] = mapAttachments
        }
        if hasData {
            jsonMap["data"] = data.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Image {
        return try Image.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Image {
        return try Image.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasWidth {
            output += "\(indent) width: \(width) \n"
        }
        if hasHeight {
            output += "\(indent) height: \(height) \n"
        }
        if hasFormat {
            output += "\(indent) format: \(format) \n"
        }
        if hasAttachments {
            output += "\(indent) attachments: \(attachments) \n"
        }
        if hasData {
            output += "\(indent) data: \(data) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasWidth {
                hashCode = (hashCode &* 31) &+ width.hashValue
            }
            if hasHeight {
                hashCode = (hashCode &* 31) &+ height.hashValue
            }
            if hasFormat {
                hashCode = (hashCode &* 31) &+ format.hashValue
            }
            if hasAttachments {
                for (keyAttachments, valueAttachments) in attachments {
                    hashCode = (hashCode &* 31) &+ keyAttachments.hashValue
                    hashCode = (hashCode &* 31) &+ valueAttachments.hashValue
                }
            }
            if hasData {
                hashCode = (hashCode &* 31) &+ data.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Image"
    }
    override public func className() -> String {
        return "Image"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Image = Image()
        public func getMessage() -> Image {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var width:Int64 {
            get {
                return builderResult.width
            }
            set (value) {
                builderResult.hasWidth = true
                builderResult.width = value
            }
        }
        public var hasWidth:Bool {
            get {
                return builderResult.hasWidth
            }
        }
        @discardableResult
        public func setWidth(_ value:Int64) -> Image.Builder {
            self.width = value
            return self
        }
        @discardableResult
        public func clearWidth() -> Image.Builder{
            builderResult.hasWidth = false
            builderResult.width = nil
            return self
        }
        public var height:Int64 {
            get {
                return builderResult.height
            }
            set (value) {
                builderResult.hasHeight = true
                builderResult.height = value
            }
        }
        public var hasHeight:Bool {
            get {
                return builderResult.hasHeight
            }
        }
        @discardableResult
        public func setHeight(_ value:Int64) -> Image.Builder {
            self.height = value
            return self
        }
        @discardableResult
        public func clearHeight() -> Image.Builder{
            builderResult.hasHeight = false
            builderResult.height = nil
            return self
        }
        public var format:UInt32 {
            get {
                return builderResult.format
            }
            set (value) {
                builderResult.hasFormat = true
                builderResult.format = value
            }
        }
        public var hasFormat:Bool {
            get {
                return builderResult.hasFormat
            }
        }
        @discardableResult
        public func setFormat(_ value:UInt32) -> Image.Builder {
            self.format = value
            return self
        }
        @discardableResult
        public func clearFormat() -> Image.Builder{
            builderResult.hasFormat = false
            builderResult.format = nil
            return self
        }
        public var hasAttachments:Bool {
            get {
                return builderResult.hasAttachments
            }
        }
        public var attachments:Dictionary<String,String> {
            get {
                return builderResult.attachments
            }
            set (value) {
                builderResult.hasAttachments = true
                builderResult.attachments = value
            }
        }
        @discardableResult
        public func setAttachments(_ value:Dictionary<String,String>) -> Image.Builder {
            self.attachments = value
            return self
        }
        @discardableResult
        public func clearAttachments() -> Image.Builder{
            builderResult.hasAttachments = false
            builderResult.attachments = Dictionary<String,String>()
            return self
        }
        public var data:Data {
            get {
                return builderResult.data
            }
            set (value) {
                builderResult.hasData = true
                builderResult.data = value
            }
        }
        public var hasData:Bool {
            get {
                return builderResult.hasData
            }
        }
        @discardableResult
        public func setData(_ value:Data) -> Image.Builder {
            self.data = value
            return self
        }
        @discardableResult
        public func clearData() -> Image.Builder{
            builderResult.hasData = false
            builderResult.data = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Image.Builder {
            builderResult = Image()
            return self
        }
        override public func clone() throws -> Image.Builder {
            return try Image.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Image {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Image {
            let returnMe:Image = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Image) throws -> Image.Builder {
            if other == Image() {
                return self
            }
            if other.hasWidth {
                width = other.width
            }
            if other.hasHeight {
                height = other.height
            }
            if other.hasFormat {
                format = other.format
            }
            if other.hasAttachments {
                attachments = other.attachments
            }
            if other.hasData {
                data = other.data
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Image.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Image.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    width = try codedInputStream.readInt64()

                case 16:
                    height = try codedInputStream.readInt64()

                case 24:
                    format = try codedInputStream.readUInt32()

                case 34:
                    let subBuilder = Image.AttachmentsEntry.Builder()
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    let buildOfAttachments = subBuilder.buildPartial()
                    attachments[buildOfAttachments.key] = buildOfAttachments.value

                case 42:
                    data = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Image.Builder {
            let resultDecodedBuilder = Image.Builder()
            if let jsonValueWidth = jsonMap["width"] as? String {
                resultDecodedBuilder.width = Int64(jsonValueWidth)!
            } else if let jsonValueWidth = jsonMap["width"] as? Int {
                resultDecodedBuilder.width = Int64(jsonValueWidth)
            }
            if let jsonValueHeight = jsonMap["height"] as? String {
                resultDecodedBuilder.height = Int64(jsonValueHeight)!
            } else if let jsonValueHeight = jsonMap["height"] as? Int {
                resultDecodedBuilder.height = Int64(jsonValueHeight)
            }
            if let jsonValueFormat = jsonMap["format"] as? UInt {
                resultDecodedBuilder.format = UInt32(jsonValueFormat)
            } else if let jsonValueFormat = jsonMap["format"] as? String {
                resultDecodedBuilder.format = UInt32(jsonValueFormat)!
            }
            if let jsonValueAttachments = jsonMap["attachments"] as? Dictionary<String, String> {
                var mapAttachments = Dictionary<String, String>()
                for (keyAttachments, valueAttachments) in jsonValueAttachments {
                    mapAttachments[keyAttachments] = valueAttachments
                }
                resultDecodedBuilder.attachments = mapAttachments
            }
            if let jsonValueData = jsonMap["data"] as? String {
                resultDecodedBuilder.data = Data(base64Encoded:jsonValueData, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Image.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Image.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class FormatDescription : GeneratedMessage {
    public typealias BuilderType = FormatDescription.Builder

    public static func == (lhs: FormatDescription, rhs: FormatDescription) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasMediaType == rhs.hasMediaType) && (!lhs.hasMediaType || lhs.mediaType == rhs.mediaType)
        fieldCheck = fieldCheck && (lhs.hasMediaSubtype == rhs.hasMediaSubtype) && (!lhs.hasMediaSubtype || lhs.mediaSubtype == rhs.mediaSubtype)
        fieldCheck = fieldCheck && (lhs.hasExtensions == rhs.hasExtensions) && (!lhs.hasExtensions || lhs.extensions == rhs.extensions)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



    //Nested type declaration start

    final public class ExtensionsEntry : GeneratedMessage {
        public typealias BuilderType = FormatDescription.ExtensionsEntry.Builder

        public static func == (lhs: FormatDescription.ExtensionsEntry, rhs: FormatDescription.ExtensionsEntry) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
            fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var key:String! = nil
        public fileprivate(set) var hasKey:Bool = false

        public fileprivate(set) var value:String! = nil
        public fileprivate(set) var hasValue:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasKey {
                try codedOutputStream.writeString(fieldNumber: 1, value:key)
            }
            if hasValue {
                try codedOutputStream.writeString(fieldNumber: 2, value:value)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasKey {
                serialize_size += key.computeStringSize(fieldNumber: 1)
            }
            if hasValue {
                serialize_size += value.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> FormatDescription.ExtensionsEntry.Builder {
            return FormatDescription.ExtensionsEntry.classBuilder() as! FormatDescription.ExtensionsEntry.Builder
        }
        public func getBuilder() -> FormatDescription.ExtensionsEntry.Builder {
            return classBuilder() as! FormatDescription.ExtensionsEntry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return FormatDescription.ExtensionsEntry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return FormatDescription.ExtensionsEntry.Builder()
        }
        public func toBuilder() throws -> FormatDescription.ExtensionsEntry.Builder {
            return try FormatDescription.ExtensionsEntry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:FormatDescription.ExtensionsEntry) throws -> FormatDescription.ExtensionsEntry.Builder {
            return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasKey {
                jsonMap["key"] = key
            }
            if hasValue {
                jsonMap["value"] = value
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> FormatDescription.ExtensionsEntry {
            return try FormatDescription.ExtensionsEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> FormatDescription.ExtensionsEntry {
            return try FormatDescription.ExtensionsEntry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasKey {
                output += "\(indent) key: \(key) \n"
            }
            if hasValue {
                output += "\(indent) value: \(value) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                    hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                    hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "FormatDescription.ExtensionsEntry"
        }
        override public func className() -> String {
            return "FormatDescription.ExtensionsEntry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:FormatDescription.ExtensionsEntry = FormatDescription.ExtensionsEntry()
            public func getMessage() -> FormatDescription.ExtensionsEntry {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var key:String {
                get {
                    return builderResult.key
                }
                set (value) {
                    builderResult.hasKey = true
                    builderResult.key = value
                }
            }
            public var hasKey:Bool {
                get {
                    return builderResult.hasKey
                }
            }
            @discardableResult
            public func setKey(_ value:String) -> FormatDescription.ExtensionsEntry.Builder {
                self.key = value
                return self
            }
            @discardableResult
            public func clearKey() -> FormatDescription.ExtensionsEntry.Builder{
                builderResult.hasKey = false
                builderResult.key = nil
                return self
            }
            public var value:String {
                get {
                    return builderResult.value
                }
                set (value) {
                    builderResult.hasValue = true
                    builderResult.value = value
                }
            }
            public var hasValue:Bool {
                get {
                    return builderResult.hasValue
                }
            }
            @discardableResult
            public func setValue(_ value:String) -> FormatDescription.ExtensionsEntry.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> FormatDescription.ExtensionsEntry.Builder{
                builderResult.hasValue = false
                builderResult.value = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> FormatDescription.ExtensionsEntry.Builder {
                builderResult = FormatDescription.ExtensionsEntry()
                return self
            }
            override public func clone() throws -> FormatDescription.ExtensionsEntry.Builder {
                return try FormatDescription.ExtensionsEntry.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> FormatDescription.ExtensionsEntry {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> FormatDescription.ExtensionsEntry {
                let returnMe:FormatDescription.ExtensionsEntry = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:FormatDescription.ExtensionsEntry) throws -> FormatDescription.ExtensionsEntry.Builder {
                if other == FormatDescription.ExtensionsEntry() {
                    return self
                }
                if other.hasKey {
                    key = other.key
                }
                if other.hasValue {
                    value = other.value
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> FormatDescription.ExtensionsEntry.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription.ExtensionsEntry.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        key = try codedInputStream.readString()

                    case 18:
                        value = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> FormatDescription.ExtensionsEntry.Builder {
                let resultDecodedBuilder = FormatDescription.ExtensionsEntry.Builder()
                if let jsonValueKey = jsonMap["key"] as? String {
                    resultDecodedBuilder.key = jsonValueKey
                }
                if let jsonValueValue = jsonMap["value"] as? String {
                    resultDecodedBuilder.value = jsonValueValue
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> FormatDescription.ExtensionsEntry.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try FormatDescription.ExtensionsEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    //Nested type declaration end

    public fileprivate(set) var mediaType:UInt32! = nil
    public fileprivate(set) var hasMediaType:Bool = false

    public fileprivate(set) var mediaSubtype:UInt32! = nil
    public fileprivate(set) var hasMediaSubtype:Bool = false

    public fileprivate(set) var extensions:Dictionary<String,String> = Dictionary<String,String>()

    public fileprivate(set) var hasExtensions:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasMediaType {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:mediaType)
        }
        if hasMediaSubtype {
            try codedOutputStream.writeUInt32(fieldNumber: 2, value:mediaSubtype)
        }
        if hasExtensions {
            for (keyExtensions, valueExtensions) in extensions {
                let valueOfExtensions = try! FormatDescription.ExtensionsEntry.Builder().setKey(keyExtensions).setValue(valueExtensions).build()
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:valueOfExtensions)
              }
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasMediaType {
            serialize_size += mediaType.computeUInt32Size(fieldNumber: 1)
        }
        if hasMediaSubtype {
            serialize_size += mediaSubtype.computeUInt32Size(fieldNumber: 2)
        }
        if hasExtensions {
              for (keyExtensions, valueExtensions) in extensions {
                  let valueOfExtensions = try! FormatDescription.ExtensionsEntry.Builder().setKey(keyExtensions).setValue(valueExtensions).build()
            serialize_size += valueOfExtensions.computeMessageSize(fieldNumber: 3)
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> FormatDescription.Builder {
        return FormatDescription.classBuilder() as! FormatDescription.Builder
    }
    public func getBuilder() -> FormatDescription.Builder {
        return classBuilder() as! FormatDescription.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return FormatDescription.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return FormatDescription.Builder()
    }
    public func toBuilder() throws -> FormatDescription.Builder {
        return try FormatDescription.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:FormatDescription) throws -> FormatDescription.Builder {
        return try FormatDescription.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasMediaType {
            jsonMap["mediaType"] = UInt(mediaType)
        }
        if hasMediaSubtype {
            jsonMap["mediaSubtype"] = UInt(mediaSubtype)
        }
        if hasExtensions {
            var mapExtensions = Dictionary<String, String>()
            for (keyExtensions, valueExtensions) in extensions {
                mapExtensions["\(keyExtensions)"] = valueExtensions
            }
            jsonMap["extensions"] = mapExtensions
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> FormatDescription {
        return try FormatDescription.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> FormatDescription {
        return try FormatDescription.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasMediaType {
            output += "\(indent) mediaType: \(mediaType) \n"
        }
        if hasMediaSubtype {
            output += "\(indent) mediaSubtype: \(mediaSubtype) \n"
        }
        if hasExtensions {
            output += "\(indent) extensions: \(extensions) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMediaType {
                hashCode = (hashCode &* 31) &+ mediaType.hashValue
            }
            if hasMediaSubtype {
                hashCode = (hashCode &* 31) &+ mediaSubtype.hashValue
            }
            if hasExtensions {
                for (keyExtensions, valueExtensions) in extensions {
                    hashCode = (hashCode &* 31) &+ keyExtensions.hashValue
                    hashCode = (hashCode &* 31) &+ valueExtensions.hashValue
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "FormatDescription"
    }
    override public func className() -> String {
        return "FormatDescription"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:FormatDescription = FormatDescription()
        public func getMessage() -> FormatDescription {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var mediaType:UInt32 {
            get {
                return builderResult.mediaType
            }
            set (value) {
                builderResult.hasMediaType = true
                builderResult.mediaType = value
            }
        }
        public var hasMediaType:Bool {
            get {
                return builderResult.hasMediaType
            }
        }
        @discardableResult
        public func setMediaType(_ value:UInt32) -> FormatDescription.Builder {
            self.mediaType = value
            return self
        }
        @discardableResult
        public func clearMediaType() -> FormatDescription.Builder{
            builderResult.hasMediaType = false
            builderResult.mediaType = nil
            return self
        }
        public var mediaSubtype:UInt32 {
            get {
                return builderResult.mediaSubtype
            }
            set (value) {
                builderResult.hasMediaSubtype = true
                builderResult.mediaSubtype = value
            }
        }
        public var hasMediaSubtype:Bool {
            get {
                return builderResult.hasMediaSubtype
            }
        }
        @discardableResult
        public func setMediaSubtype(_ value:UInt32) -> FormatDescription.Builder {
            self.mediaSubtype = value
            return self
        }
        @discardableResult
        public func clearMediaSubtype() -> FormatDescription.Builder{
            builderResult.hasMediaSubtype = false
            builderResult.mediaSubtype = nil
            return self
        }
        public var hasExtensions:Bool {
            get {
                return builderResult.hasExtensions
            }
        }
        public var extensions:Dictionary<String,String> {
            get {
                return builderResult.extensions
            }
            set (value) {
                builderResult.hasExtensions = true
                builderResult.extensions = value
            }
        }
        @discardableResult
        public func setExtensions(_ value:Dictionary<String,String>) -> FormatDescription.Builder {
            self.extensions = value
            return self
        }
        @discardableResult
        public func clearExtensions() -> FormatDescription.Builder{
            builderResult.hasExtensions = false
            builderResult.extensions = Dictionary<String,String>()
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> FormatDescription.Builder {
            builderResult = FormatDescription()
            return self
        }
        override public func clone() throws -> FormatDescription.Builder {
            return try FormatDescription.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> FormatDescription {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> FormatDescription {
            let returnMe:FormatDescription = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:FormatDescription) throws -> FormatDescription.Builder {
            if other == FormatDescription() {
                return self
            }
            if other.hasMediaType {
                mediaType = other.mediaType
            }
            if other.hasMediaSubtype {
                mediaSubtype = other.mediaSubtype
            }
            if other.hasExtensions {
                extensions = other.extensions
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> FormatDescription.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    mediaType = try codedInputStream.readUInt32()

                case 16:
                    mediaSubtype = try codedInputStream.readUInt32()

                case 26:
                    let subBuilder = FormatDescription.ExtensionsEntry.Builder()
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    let buildOfExtensions = subBuilder.buildPartial()
                    extensions[buildOfExtensions.key] = buildOfExtensions.value

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> FormatDescription.Builder {
            let resultDecodedBuilder = FormatDescription.Builder()
            if let jsonValueMediaType = jsonMap["mediaType"] as? UInt {
                resultDecodedBuilder.mediaType = UInt32(jsonValueMediaType)
            } else if let jsonValueMediaType = jsonMap["mediaType"] as? String {
                resultDecodedBuilder.mediaType = UInt32(jsonValueMediaType)!
            }
            if let jsonValueMediaSubtype = jsonMap["mediaSubtype"] as? UInt {
                resultDecodedBuilder.mediaSubtype = UInt32(jsonValueMediaSubtype)
            } else if let jsonValueMediaSubtype = jsonMap["mediaSubtype"] as? String {
                resultDecodedBuilder.mediaSubtype = UInt32(jsonValueMediaSubtype)!
            }
            if let jsonValueExtensions = jsonMap["extensions"] as? Dictionary<String, String> {
                var mapExtensions = Dictionary<String, String>()
                for (keyExtensions, valueExtensions) in jsonValueExtensions {
                    mapExtensions[keyExtensions] = valueExtensions
                }
                resultDecodedBuilder.extensions = mapExtensions
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> FormatDescription.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try FormatDescription.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class VideoSample : GeneratedMessage {
    public typealias BuilderType = VideoSample.Builder

    public static func == (lhs: VideoSample, rhs: VideoSample) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasImage == rhs.hasImage) && (!lhs.hasImage || lhs.image == rhs.image)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var image:Image!
    public fileprivate(set) var hasImage:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasImage {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:image)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasImage {
            if let varSizeimage = image?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizeimage
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> VideoSample.Builder {
        return VideoSample.classBuilder() as! VideoSample.Builder
    }
    public func getBuilder() -> VideoSample.Builder {
        return classBuilder() as! VideoSample.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return VideoSample.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return VideoSample.Builder()
    }
    public func toBuilder() throws -> VideoSample.Builder {
        return try VideoSample.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:VideoSample) throws -> VideoSample.Builder {
        return try VideoSample.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasImage {
            jsonMap["image"] = try image.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> VideoSample {
        return try VideoSample.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> VideoSample {
        return try VideoSample.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasImage {
            output += "\(indent) image {\n"
            if let outDescImage = image {
                output += try outDescImage.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasImage {
                if let hashValueimage = image?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueimage
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "VideoSample"
    }
    override public func className() -> String {
        return "VideoSample"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:VideoSample = VideoSample()
        public func getMessage() -> VideoSample {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var image:Image! {
            get {
                if imageBuilder_ != nil {
                    builderResult.image = imageBuilder_.getMessage()
                }
                return builderResult.image
            }
            set (value) {
                builderResult.hasImage = value != nil
                builderResult.image = value
            }
        }
        public var hasImage:Bool {
            get {
                return builderResult.hasImage
            }
        }
        fileprivate var imageBuilder_:Image.Builder! {
            didSet {
                builderResult.hasImage = true
            }
        }
        public func getImageBuilder() -> Image.Builder {
            if imageBuilder_ == nil {
                imageBuilder_ = Image.Builder()
                builderResult.image = imageBuilder_.getMessage()
                if image != nil {
                    try! imageBuilder_.mergeFrom(other: image)
                }
            }
            return imageBuilder_
        }
        @discardableResult
        public func setImage(_ value:Image!) -> VideoSample.Builder {
            self.image = value
            return self
        }
        @discardableResult
        public func mergeImage(value:Image) throws -> VideoSample.Builder {
            if builderResult.hasImage {
                builderResult.image = try Image.builderWithPrototype(prototype:builderResult.image).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.image = value
            }
            builderResult.hasImage = true
            return self
        }
        @discardableResult
        public func clearImage() -> VideoSample.Builder {
            imageBuilder_ = nil
            builderResult.hasImage = false
            builderResult.image = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> VideoSample.Builder {
            builderResult = VideoSample()
            return self
        }
        override public func clone() throws -> VideoSample.Builder {
            return try VideoSample.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> VideoSample {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> VideoSample {
            let returnMe:VideoSample = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:VideoSample) throws -> VideoSample.Builder {
            if other == VideoSample() {
                return self
            }
            if (other.hasImage) {
                try mergeImage(value: other.image)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> VideoSample.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VideoSample.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:Image.Builder = Image.Builder()
                    if hasImage {
                        try subBuilder.mergeFrom(other: image)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    image = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> VideoSample.Builder {
            let resultDecodedBuilder = VideoSample.Builder()
            if let jsonValueImage = jsonMap["image"] as? Dictionary<String,Any> {
                resultDecodedBuilder.image = try Image.Builder.decodeToBuilder(jsonMap:jsonValueImage).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> VideoSample.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try VideoSample.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class AudioSample : GeneratedMessage {
    public typealias BuilderType = AudioSample.Builder

    public static func == (lhs: AudioSample, rhs: AudioSample) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasImage == rhs.hasImage) && (!lhs.hasImage || lhs.image == rhs.image)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var image:Image!
    public fileprivate(set) var hasImage:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasImage {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:image)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasImage {
            if let varSizeimage = image?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizeimage
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> AudioSample.Builder {
        return AudioSample.classBuilder() as! AudioSample.Builder
    }
    public func getBuilder() -> AudioSample.Builder {
        return classBuilder() as! AudioSample.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AudioSample.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AudioSample.Builder()
    }
    public func toBuilder() throws -> AudioSample.Builder {
        return try AudioSample.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:AudioSample) throws -> AudioSample.Builder {
        return try AudioSample.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasImage {
            jsonMap["image"] = try image.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> AudioSample {
        return try AudioSample.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> AudioSample {
        return try AudioSample.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasImage {
            output += "\(indent) image {\n"
            if let outDescImage = image {
                output += try outDescImage.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasImage {
                if let hashValueimage = image?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueimage
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "AudioSample"
    }
    override public func className() -> String {
        return "AudioSample"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:AudioSample = AudioSample()
        public func getMessage() -> AudioSample {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var image:Image! {
            get {
                if imageBuilder_ != nil {
                    builderResult.image = imageBuilder_.getMessage()
                }
                return builderResult.image
            }
            set (value) {
                builderResult.hasImage = value != nil
                builderResult.image = value
            }
        }
        public var hasImage:Bool {
            get {
                return builderResult.hasImage
            }
        }
        fileprivate var imageBuilder_:Image.Builder! {
            didSet {
                builderResult.hasImage = true
            }
        }
        public func getImageBuilder() -> Image.Builder {
            if imageBuilder_ == nil {
                imageBuilder_ = Image.Builder()
                builderResult.image = imageBuilder_.getMessage()
                if image != nil {
                    try! imageBuilder_.mergeFrom(other: image)
                }
            }
            return imageBuilder_
        }
        @discardableResult
        public func setImage(_ value:Image!) -> AudioSample.Builder {
            self.image = value
            return self
        }
        @discardableResult
        public func mergeImage(value:Image) throws -> AudioSample.Builder {
            if builderResult.hasImage {
                builderResult.image = try Image.builderWithPrototype(prototype:builderResult.image).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.image = value
            }
            builderResult.hasImage = true
            return self
        }
        @discardableResult
        public func clearImage() -> AudioSample.Builder {
            imageBuilder_ = nil
            builderResult.hasImage = false
            builderResult.image = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> AudioSample.Builder {
            builderResult = AudioSample()
            return self
        }
        override public func clone() throws -> AudioSample.Builder {
            return try AudioSample.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> AudioSample {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> AudioSample {
            let returnMe:AudioSample = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:AudioSample) throws -> AudioSample.Builder {
            if other == AudioSample() {
                return self
            }
            if (other.hasImage) {
                try mergeImage(value: other.image)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> AudioSample.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AudioSample.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:Image.Builder = Image.Builder()
                    if hasImage {
                        try subBuilder.mergeFrom(other: image)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    image = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> AudioSample.Builder {
            let resultDecodedBuilder = AudioSample.Builder()
            if let jsonValueImage = jsonMap["image"] as? Dictionary<String,Any> {
                resultDecodedBuilder.image = try Image.Builder.decodeToBuilder(jsonMap:jsonValueImage).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> AudioSample.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try AudioSample.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Av : GeneratedMessage {
    public typealias BuilderType = Av.Builder

    public static func == (lhs: Av, rhs: Av) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasVideo == rhs.hasVideo) && (!lhs.hasVideo || lhs.video == rhs.video)
        fieldCheck = fieldCheck && (lhs.hasAudio == rhs.hasAudio) && (!lhs.hasAudio || lhs.audio == rhs.audio)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var video:VideoSample!
    public fileprivate(set) var hasVideo:Bool = false
    public fileprivate(set) var audio:AudioSample!
    public fileprivate(set) var hasAudio:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasVideo {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:video)
        }
        if hasAudio {
            try codedOutputStream.writeMessage(fieldNumber: 2, value:audio)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasVideo {
            if let varSizevideo = video?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizevideo
            }
        }
        if hasAudio {
            if let varSizeaudio = audio?.computeMessageSize(fieldNumber: 2) {
                serialize_size += varSizeaudio
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Av.Builder {
        return Av.classBuilder() as! Av.Builder
    }
    public func getBuilder() -> Av.Builder {
        return classBuilder() as! Av.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Av.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Av.Builder()
    }
    public func toBuilder() throws -> Av.Builder {
        return try Av.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Av) throws -> Av.Builder {
        return try Av.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasVideo {
            jsonMap["video"] = try video.encode()
        }
        if hasAudio {
            jsonMap["audio"] = try audio.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Av {
        return try Av.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Av {
        return try Av.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasVideo {
            output += "\(indent) video {\n"
            if let outDescVideo = video {
                output += try outDescVideo.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasAudio {
            output += "\(indent) audio {\n"
            if let outDescAudio = audio {
                output += try outDescAudio.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVideo {
                if let hashValuevideo = video?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuevideo
                }
            }
            if hasAudio {
                if let hashValueaudio = audio?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueaudio
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Av"
    }
    override public func className() -> String {
        return "Av"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Av = Av()
        public func getMessage() -> Av {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var video:VideoSample! {
            get {
                if videoBuilder_ != nil {
                    builderResult.video = videoBuilder_.getMessage()
                }
                return builderResult.video
            }
            set (value) {
                builderResult.hasVideo = value != nil
                builderResult.video = value
            }
        }
        public var hasVideo:Bool {
            get {
                return builderResult.hasVideo
            }
        }
        fileprivate var videoBuilder_:VideoSample.Builder! {
            didSet {
                builderResult.hasVideo = true
            }
        }
        public func getVideoBuilder() -> VideoSample.Builder {
            if videoBuilder_ == nil {
                videoBuilder_ = VideoSample.Builder()
                builderResult.video = videoBuilder_.getMessage()
                if video != nil {
                    try! videoBuilder_.mergeFrom(other: video)
                }
            }
            return videoBuilder_
        }
        @discardableResult
        public func setVideo(_ value:VideoSample!) -> Av.Builder {
            self.video = value
            return self
        }
        @discardableResult
        public func mergeVideo(value:VideoSample) throws -> Av.Builder {
            if builderResult.hasVideo {
                builderResult.video = try VideoSample.builderWithPrototype(prototype:builderResult.video).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.video = value
            }
            builderResult.hasVideo = true
            return self
        }
        @discardableResult
        public func clearVideo() -> Av.Builder {
            videoBuilder_ = nil
            builderResult.hasVideo = false
            builderResult.video = nil
            return self
        }
        public var audio:AudioSample! {
            get {
                if audioBuilder_ != nil {
                    builderResult.audio = audioBuilder_.getMessage()
                }
                return builderResult.audio
            }
            set (value) {
                builderResult.hasAudio = value != nil
                builderResult.audio = value
            }
        }
        public var hasAudio:Bool {
            get {
                return builderResult.hasAudio
            }
        }
        fileprivate var audioBuilder_:AudioSample.Builder! {
            didSet {
                builderResult.hasAudio = true
            }
        }
        public func getAudioBuilder() -> AudioSample.Builder {
            if audioBuilder_ == nil {
                audioBuilder_ = AudioSample.Builder()
                builderResult.audio = audioBuilder_.getMessage()
                if audio != nil {
                    try! audioBuilder_.mergeFrom(other: audio)
                }
            }
            return audioBuilder_
        }
        @discardableResult
        public func setAudio(_ value:AudioSample!) -> Av.Builder {
            self.audio = value
            return self
        }
        @discardableResult
        public func mergeAudio(value:AudioSample) throws -> Av.Builder {
            if builderResult.hasAudio {
                builderResult.audio = try AudioSample.builderWithPrototype(prototype:builderResult.audio).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.audio = value
            }
            builderResult.hasAudio = true
            return self
        }
        @discardableResult
        public func clearAudio() -> Av.Builder {
            audioBuilder_ = nil
            builderResult.hasAudio = false
            builderResult.audio = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Av.Builder {
            builderResult = Av()
            return self
        }
        override public func clone() throws -> Av.Builder {
            return try Av.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Av {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Av {
            let returnMe:Av = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Av) throws -> Av.Builder {
            if other == Av() {
                return self
            }
            if (other.hasVideo) {
                try mergeVideo(value: other.video)
            }
            if (other.hasAudio) {
                try mergeAudio(value: other.audio)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Av.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Av.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:VideoSample.Builder = VideoSample.Builder()
                    if hasVideo {
                        try subBuilder.mergeFrom(other: video)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    video = subBuilder.buildPartial()

                case 18:
                    let subBuilder:AudioSample.Builder = AudioSample.Builder()
                    if hasAudio {
                        try subBuilder.mergeFrom(other: audio)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    audio = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Av.Builder {
            let resultDecodedBuilder = Av.Builder()
            if let jsonValueVideo = jsonMap["video"] as? Dictionary<String,Any> {
                resultDecodedBuilder.video = try VideoSample.Builder.decodeToBuilder(jsonMap:jsonValueVideo).build()

            }
            if let jsonValueAudio = jsonMap["audio"] as? Dictionary<String,Any> {
                resultDecodedBuilder.audio = try AudioSample.Builder.decodeToBuilder(jsonMap:jsonValueAudio).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Av.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Av.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Avsession : GeneratedMessage {
    public typealias BuilderType = Avsession.Builder

    public static func == (lhs: Avsession, rhs: Avsession) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasSid == rhs.hasSid) && (!lhs.hasSid || lhs.sid == rhs.sid)
        fieldCheck = fieldCheck && (lhs.hasGid == rhs.hasGid) && (!lhs.hasGid || lhs.gid == rhs.gid)
        fieldCheck = fieldCheck && (lhs.hasActive == rhs.hasActive) && (!lhs.hasActive || lhs.active == rhs.active)
        fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var sid:String! = nil
    public fileprivate(set) var hasSid:Bool = false

    public fileprivate(set) var gid:String! = nil
    public fileprivate(set) var hasGid:Bool = false

    public fileprivate(set) var active:Bool! = nil
    public fileprivate(set) var hasActive:Bool = false

    public fileprivate(set) var data:Data! = nil
    public fileprivate(set) var hasData:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasSid {
            try codedOutputStream.writeString(fieldNumber: 1, value:sid)
        }
        if hasGid {
            try codedOutputStream.writeString(fieldNumber: 2, value:gid)
        }
        if hasActive {
            try codedOutputStream.writeBool(fieldNumber: 3, value:active)
        }
        if hasData {
            try codedOutputStream.writeData(fieldNumber: 4, value:data)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSid {
            serialize_size += sid.computeStringSize(fieldNumber: 1)
        }
        if hasGid {
            serialize_size += gid.computeStringSize(fieldNumber: 2)
        }
        if hasActive {
            serialize_size += active.computeBoolSize(fieldNumber: 3)
        }
        if hasData {
            serialize_size += data.computeDataSize(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Avsession.Builder {
        return Avsession.classBuilder() as! Avsession.Builder
    }
    public func getBuilder() -> Avsession.Builder {
        return classBuilder() as! Avsession.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Avsession.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Avsession.Builder()
    }
    public func toBuilder() throws -> Avsession.Builder {
        return try Avsession.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Avsession) throws -> Avsession.Builder {
        return try Avsession.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasSid {
            jsonMap["sid"] = sid
        }
        if hasGid {
            jsonMap["gid"] = gid
        }
        if hasActive {
            jsonMap["active"] = active
        }
        if hasData {
            jsonMap["data"] = data.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Avsession {
        return try Avsession.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Avsession {
        return try Avsession.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasSid {
            output += "\(indent) sid: \(sid) \n"
        }
        if hasGid {
            output += "\(indent) gid: \(gid) \n"
        }
        if hasActive {
            output += "\(indent) active: \(active) \n"
        }
        if hasData {
            output += "\(indent) data: \(data) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSid {
                hashCode = (hashCode &* 31) &+ sid.hashValue
            }
            if hasGid {
                hashCode = (hashCode &* 31) &+ gid.hashValue
            }
            if hasActive {
                hashCode = (hashCode &* 31) &+ active.hashValue
            }
            if hasData {
                hashCode = (hashCode &* 31) &+ data.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Avsession"
    }
    override public func className() -> String {
        return "Avsession"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Avsession = Avsession()
        public func getMessage() -> Avsession {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var sid:String {
            get {
                return builderResult.sid
            }
            set (value) {
                builderResult.hasSid = true
                builderResult.sid = value
            }
        }
        public var hasSid:Bool {
            get {
                return builderResult.hasSid
            }
        }
        @discardableResult
        public func setSid(_ value:String) -> Avsession.Builder {
            self.sid = value
            return self
        }
        @discardableResult
        public func clearSid() -> Avsession.Builder{
            builderResult.hasSid = false
            builderResult.sid = nil
            return self
        }
        public var gid:String {
            get {
                return builderResult.gid
            }
            set (value) {
                builderResult.hasGid = true
                builderResult.gid = value
            }
        }
        public var hasGid:Bool {
            get {
                return builderResult.hasGid
            }
        }
        @discardableResult
        public func setGid(_ value:String) -> Avsession.Builder {
            self.gid = value
            return self
        }
        @discardableResult
        public func clearGid() -> Avsession.Builder{
            builderResult.hasGid = false
            builderResult.gid = nil
            return self
        }
        public var active:Bool {
            get {
                return builderResult.active
            }
            set (value) {
                builderResult.hasActive = true
                builderResult.active = value
            }
        }
        public var hasActive:Bool {
            get {
                return builderResult.hasActive
            }
        }
        @discardableResult
        public func setActive(_ value:Bool) -> Avsession.Builder {
            self.active = value
            return self
        }
        @discardableResult
        public func clearActive() -> Avsession.Builder{
            builderResult.hasActive = false
            builderResult.active = nil
            return self
        }
        public var data:Data {
            get {
                return builderResult.data
            }
            set (value) {
                builderResult.hasData = true
                builderResult.data = value
            }
        }
        public var hasData:Bool {
            get {
                return builderResult.hasData
            }
        }
        @discardableResult
        public func setData(_ value:Data) -> Avsession.Builder {
            self.data = value
            return self
        }
        @discardableResult
        public func clearData() -> Avsession.Builder{
            builderResult.hasData = false
            builderResult.data = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Avsession.Builder {
            builderResult = Avsession()
            return self
        }
        override public func clone() throws -> Avsession.Builder {
            return try Avsession.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Avsession {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Avsession {
            let returnMe:Avsession = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Avsession) throws -> Avsession.Builder {
            if other == Avsession() {
                return self
            }
            if other.hasSid {
                sid = other.sid
            }
            if other.hasGid {
                gid = other.gid
            }
            if other.hasActive {
                active = other.active
            }
            if other.hasData {
                data = other.data
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Avsession.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Avsession.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    sid = try codedInputStream.readString()

                case 18:
                    gid = try codedInputStream.readString()

                case 24:
                    active = try codedInputStream.readBool()

                case 34:
                    data = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Avsession.Builder {
            let resultDecodedBuilder = Avsession.Builder()
            if let jsonValueSid = jsonMap["sid"] as? String {
                resultDecodedBuilder.sid = jsonValueSid
            }
            if let jsonValueGid = jsonMap["gid"] as? String {
                resultDecodedBuilder.gid = jsonValueGid
            }
            if let jsonValueActive = jsonMap["active"] as? Bool {
                resultDecodedBuilder.active = jsonValueActive
            }
            if let jsonValueData = jsonMap["data"] as? String {
                resultDecodedBuilder.data = Data(base64Encoded:jsonValueData, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Avsession.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Avsession.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Avquality : GeneratedMessage {
    public typealias BuilderType = Avquality.Builder

    public static func == (lhs: Avquality, rhs: Avquality) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasDiff == rhs.hasDiff) && (!lhs.hasDiff || lhs.diff == rhs.diff)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var diff:Int32! = nil
    public fileprivate(set) var hasDiff:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasDiff {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:diff)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasDiff {
            serialize_size += diff.computeInt32Size(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Avquality.Builder {
        return Avquality.classBuilder() as! Avquality.Builder
    }
    public func getBuilder() -> Avquality.Builder {
        return classBuilder() as! Avquality.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Avquality.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Avquality.Builder()
    }
    public func toBuilder() throws -> Avquality.Builder {
        return try Avquality.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Avquality) throws -> Avquality.Builder {
        return try Avquality.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasDiff {
            jsonMap["diff"] = Int(diff)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Avquality {
        return try Avquality.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Avquality {
        return try Avquality.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasDiff {
            output += "\(indent) diff: \(diff) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDiff {
                hashCode = (hashCode &* 31) &+ diff.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Avquality"
    }
    override public func className() -> String {
        return "Avquality"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Avquality = Avquality()
        public func getMessage() -> Avquality {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var diff:Int32 {
            get {
                return builderResult.diff
            }
            set (value) {
                builderResult.hasDiff = true
                builderResult.diff = value
            }
        }
        public var hasDiff:Bool {
            get {
                return builderResult.hasDiff
            }
        }
        @discardableResult
        public func setDiff(_ value:Int32) -> Avquality.Builder {
            self.diff = value
            return self
        }
        @discardableResult
        public func clearDiff() -> Avquality.Builder{
            builderResult.hasDiff = false
            builderResult.diff = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Avquality.Builder {
            builderResult = Avquality()
            return self
        }
        override public func clone() throws -> Avquality.Builder {
            return try Avquality.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Avquality {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Avquality {
            let returnMe:Avquality = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Avquality) throws -> Avquality.Builder {
            if other == Avquality() {
                return self
            }
            if other.hasDiff {
                diff = other.diff
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Avquality.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Avquality.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    diff = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Avquality.Builder {
            let resultDecodedBuilder = Avquality.Builder()
            if let jsonValueDiff = jsonMap["diff"] as? Int {
                resultDecodedBuilder.diff = Int32(jsonValueDiff)
            } else if let jsonValueDiff = jsonMap["diff"] as? String {
                resultDecodedBuilder.diff = Int32(jsonValueDiff)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Avquality.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Avquality.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Voip : GeneratedMessage {
    public typealias BuilderType = Voip.Builder

    public static func == (lhs: Voip, rhs: Voip) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = fieldCheck && (lhs.hasWhich == rhs.hasWhich) && (!lhs.hasWhich || lhs.which == rhs.which)
        fieldCheck = fieldCheck && (lhs.hasAvQuality == rhs.hasAvQuality) && (!lhs.hasAvQuality || lhs.avQuality == rhs.avQuality)
        fieldCheck = fieldCheck && (lhs.textStorage == rhs.textStorage)
        fieldCheck = fieldCheck && (lhs.hasFile == rhs.hasFile) && (!lhs.hasFile || lhs.file == rhs.file)
        fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
        fieldCheck = fieldCheck && (lhs.hasCall == rhs.hasCall) && (!lhs.hasCall || lhs.call == rhs.call)
        fieldCheck = fieldCheck && (lhs.hasAv == rhs.hasAv) && (!lhs.hasAv || lhs.av == rhs.av)
        fieldCheck = fieldCheck && (lhs.hasAudioSession == rhs.hasAudioSession) && (!lhs.hasAudioSession || lhs.audioSession == rhs.audioSession)
        fieldCheck = fieldCheck && (lhs.hasVideoSession == rhs.hasVideoSession) && (!lhs.hasVideoSession || lhs.videoSession == rhs.videoSession)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



        //Enum type declaration start 

        /// Identifies which field is filled in
        public enum Which:Int32, GeneratedEnum {
            case text = 0
            case file = 1
            case av = 2
            case audioSession = 3
            case videoSession = 4
            case callProposal = 5
            case callCancel = 6
            case callAccept = 7
            case callDecline = 8
            case callStartOutgoing = 9
            case callStartIncoming = 10
            case callQuality = 11
            case callStop = 12
            public func toString() -> String {
                switch self {
                case .text: return "TEXT"
                case .file: return "FILE"
                case .av: return "AV"
                case .audioSession: return "AudioSession"
                case .videoSession: return "VideoSession"
                case .callProposal: return "CALL_PROPOSAL"
                case .callCancel: return "CALL_CANCEL"
                case .callAccept: return "CALL_ACCEPT"
                case .callDecline: return "CALL_DECLINE"
                case .callStartOutgoing: return "CALL_START_OUTGOING"
                case .callStartIncoming: return "CALL_START_INCOMING"
                case .callQuality: return "CALL_QUALITY"
                case .callStop: return "CALL_STOP"
                }
            }
            public static func fromString(_ str:String) throws -> Voip.Which {
                switch str {
                case "TEXT":    return .text
                case "FILE":    return .file
                case "AV":    return .av
                case "AudioSession":    return .audioSession
                case "VideoSession":    return .videoSession
                case "CALL_PROPOSAL":    return .callProposal
                case "CALL_CANCEL":    return .callCancel
                case "CALL_ACCEPT":    return .callAccept
                case "CALL_DECLINE":    return .callDecline
                case "CALL_START_OUTGOING":    return .callStartOutgoing
                case "CALL_START_INCOMING":    return .callStartIncoming
                case "CALL_QUALITY":    return .callQuality
                case "CALL_STOP":    return .callStop
                default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                }
            }
            public var debugDescription:String { return getDescription() }
            public var description:String { return getDescription() }
            private func getDescription() -> String { 
                switch self {
                case .text: return ".text"
                case .file: return ".file"
                case .av: return ".av"
                case .audioSession: return ".audioSession"
                case .videoSession: return ".videoSession"
                case .callProposal: return ".callProposal"
                case .callCancel: return ".callCancel"
                case .callAccept: return ".callAccept"
                case .callDecline: return ".callDecline"
                case .callStartOutgoing: return ".callStartOutgoing"
                case .callStartIncoming: return ".callStartIncoming"
                case .callQuality: return ".callQuality"
                case .callStop: return ".callStop"
                }
            }
            public var hashValue:Int {
                return self.rawValue.hashValue
            }
            public static func ==(lhs:Which, rhs:Which) -> Bool {
                return lhs.hashValue == rhs.hashValue
            }
        }

        //Enum type declaration end 

    public fileprivate(set) var version:UInt32! = nil
    public fileprivate(set) var hasVersion:Bool = false

    public fileprivate(set) var which:Voip.Which = Voip.Which.text
    public fileprivate(set) var hasWhich:Bool = false
    public fileprivate(set) var textStorage:Array<Text>  = Array<Text>()
    public fileprivate(set) var file:File!
    public fileprivate(set) var hasFile:Bool = false
    public fileprivate(set) var payload:Data! = nil
    public fileprivate(set) var hasPayload:Bool = false

    public fileprivate(set) var call:Call!
    public fileprivate(set) var hasCall:Bool = false
    public fileprivate(set) var av:Av!
    public fileprivate(set) var hasAv:Bool = false
    public fileprivate(set) var audioSession:Avsession!
    public fileprivate(set) var hasAudioSession:Bool = false
    public fileprivate(set) var videoSession:Avsession!
    public fileprivate(set) var hasVideoSession:Bool = false
    public fileprivate(set) var avQuality:Avquality!
    public fileprivate(set) var hasAvQuality:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() throws {
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasVersion {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:version)
        }
        if hasWhich {
            try codedOutputStream.writeEnum(fieldNumber: 12, value:which.rawValue)
        }
        if hasAvQuality {
            try codedOutputStream.writeMessage(fieldNumber: 18, value:avQuality)
        }
        for oneElementTextStorage in textStorage {
              try codedOutputStream.writeMessage(fieldNumber: 101, value:oneElementTextStorage)
        }
        if hasFile {
            try codedOutputStream.writeMessage(fieldNumber: 102, value:file)
        }
        if hasPayload {
            try codedOutputStream.writeData(fieldNumber: 103, value:payload)
        }
        if hasCall {
            try codedOutputStream.writeMessage(fieldNumber: 104, value:call)
        }
        if hasAv {
            try codedOutputStream.writeMessage(fieldNumber: 105, value:av)
        }
        if hasAudioSession {
            try codedOutputStream.writeMessage(fieldNumber: 106, value:audioSession)
        }
        if hasVideoSession {
            try codedOutputStream.writeMessage(fieldNumber: 107, value:videoSession)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasVersion {
            serialize_size += version.computeUInt32Size(fieldNumber: 1)
        }
        if (hasWhich) {
            serialize_size += which.rawValue.computeEnumSize(fieldNumber: 12)
        }
        if hasAvQuality {
            if let varSizeavQuality = avQuality?.computeMessageSize(fieldNumber: 18) {
                serialize_size += varSizeavQuality
            }
        }
        for oneElementTextStorage in textStorage {
            serialize_size += oneElementTextStorage.computeMessageSize(fieldNumber: 101)
        }
        if hasFile {
            if let varSizefile = file?.computeMessageSize(fieldNumber: 102) {
                serialize_size += varSizefile
            }
        }
        if hasPayload {
            serialize_size += payload.computeDataSize(fieldNumber: 103)
        }
        if hasCall {
            if let varSizecall = call?.computeMessageSize(fieldNumber: 104) {
                serialize_size += varSizecall
            }
        }
        if hasAv {
            if let varSizeav = av?.computeMessageSize(fieldNumber: 105) {
                serialize_size += varSizeav
            }
        }
        if hasAudioSession {
            if let varSizeaudioSession = audioSession?.computeMessageSize(fieldNumber: 106) {
                serialize_size += varSizeaudioSession
            }
        }
        if hasVideoSession {
            if let varSizevideoSession = videoSession?.computeMessageSize(fieldNumber: 107) {
                serialize_size += varSizevideoSession
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Voip.Builder {
        return Voip.classBuilder() as! Voip.Builder
    }
    public func getBuilder() -> Voip.Builder {
        return classBuilder() as! Voip.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Voip.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Voip.Builder()
    }
    public func toBuilder() throws -> Voip.Builder {
        return try Voip.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Voip) throws -> Voip.Builder {
        return try Voip.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        try isInitialized()
        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasVersion {
            jsonMap["version"] = UInt(version)
        }
        if hasWhich {
            jsonMap["which"] = which.toString()
        }
        if !textStorage.isEmpty {
            var jsonArrayTextStorage:Array<Dictionary<String,Any>> = []
            for oneValueTextStorage in textStorage {
                let ecodedMessageTextStorage = try oneValueTextStorage.encode()
                jsonArrayTextStorage.append(ecodedMessageTextStorage)
            }
            jsonMap["textStorage"] = jsonArrayTextStorage
        }
        if hasFile {
            jsonMap["file"] = try file.encode()
        }
        if hasPayload {
            jsonMap["payload"] = payload.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        if hasCall {
            jsonMap["call"] = try call.encode()
        }
        if hasAv {
            jsonMap["av"] = try av.encode()
        }
        if hasAudioSession {
            jsonMap["audioSession"] = try audioSession.encode()
        }
        if hasVideoSession {
            jsonMap["videoSession"] = try videoSession.encode()
        }
        if hasAvQuality {
            jsonMap["avQuality"] = try avQuality.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Voip {
        return try Voip.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Voip {
        return try Voip.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasVersion {
            output += "\(indent) version: \(version) \n"
        }
        if (hasWhich) {
            output += "\(indent) which: \(which.description)\n"
        }
        if hasAvQuality {
            output += "\(indent) avQuality {\n"
            if let outDescAvQuality = avQuality {
                output += try outDescAvQuality.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        var textStorageElementIndex:Int = 0
        for oneElementTextStorage in textStorage {
            output += "\(indent) textStorage[\(textStorageElementIndex)] {\n"
            output += try oneElementTextStorage.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            textStorageElementIndex += 1
        }
        if hasFile {
            output += "\(indent) file {\n"
            if let outDescFile = file {
                output += try outDescFile.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasPayload {
            output += "\(indent) payload: \(payload) \n"
        }
        if hasCall {
            output += "\(indent) call {\n"
            if let outDescCall = call {
                output += try outDescCall.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasAv {
            output += "\(indent) av {\n"
            if let outDescAv = av {
                output += try outDescAv.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasAudioSession {
            output += "\(indent) audioSession {\n"
            if let outDescAudioSession = audioSession {
                output += try outDescAudioSession.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasVideoSession {
            output += "\(indent) videoSession {\n"
            if let outDescVideoSession = videoSession {
                output += try outDescVideoSession.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasWhich {
                 hashCode = (hashCode &* 31) &+ which.hashValue
            }
            if hasAvQuality {
                if let hashValueavQuality = avQuality?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueavQuality
                }
            }
            for oneElementTextStorage in textStorage {
                hashCode = (hashCode &* 31) &+ oneElementTextStorage.hashValue
            }
            if hasFile {
                if let hashValuefile = file?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuefile
                }
            }
            if hasPayload {
                hashCode = (hashCode &* 31) &+ payload.hashValue
            }
            if hasCall {
                if let hashValuecall = call?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecall
                }
            }
            if hasAv {
                if let hashValueav = av?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueav
                }
            }
            if hasAudioSession {
                if let hashValueaudioSession = audioSession?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueaudioSession
                }
            }
            if hasVideoSession {
                if let hashValuevideoSession = videoSession?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuevideoSession
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Voip"
    }
    override public func className() -> String {
        return "Voip"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Voip = Voip()
        public func getMessage() -> Voip {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var version:UInt32 {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:UInt32) -> Voip.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> Voip.Builder{
            builderResult.hasVersion = false
            builderResult.version = nil
            return self
        }
            public var which:Voip.Which {
                get {
                    return builderResult.which
                }
                set (value) {
                    builderResult.hasWhich = true
                    builderResult.which = value
                }
            }
            public var hasWhich:Bool{
                get {
                    return builderResult.hasWhich
                }
            }
        @discardableResult
            public func setWhich(_ value:Voip.Which) -> Voip.Builder {
              self.which = value
              return self
            }
        @discardableResult
            public func clearWhich() -> Voip.Builder {
               builderResult.hasWhich = false
               builderResult.which = .text
               return self
            }
        public var textStorage:Array<Text> {
            get {
                return builderResult.textStorage
            }
            set (value) {
                builderResult.textStorage = value
            }
        }
        @discardableResult
        public func setTextStorage(_ value:Array<Text>) -> Voip.Builder {
            self.textStorage = value
            return self
        }
        @discardableResult
        public func clearTextStorage() -> Voip.Builder {
            builderResult.textStorage.removeAll(keepingCapacity: false)
            return self
        }
        public var file:File! {
            get {
                if fileBuilder_ != nil {
                    builderResult.file = fileBuilder_.getMessage()
                }
                return builderResult.file
            }
            set (value) {
                builderResult.hasFile = value != nil
                builderResult.file = value
            }
        }
        public var hasFile:Bool {
            get {
                return builderResult.hasFile
            }
        }
        fileprivate var fileBuilder_:File.Builder! {
            didSet {
                builderResult.hasFile = true
            }
        }
        public func getFileBuilder() -> File.Builder {
            if fileBuilder_ == nil {
                fileBuilder_ = File.Builder()
                builderResult.file = fileBuilder_.getMessage()
                if file != nil {
                    try! fileBuilder_.mergeFrom(other: file)
                }
            }
            return fileBuilder_
        }
        @discardableResult
        public func setFile(_ value:File!) -> Voip.Builder {
            self.file = value
            return self
        }
        @discardableResult
        public func mergeFile(value:File) throws -> Voip.Builder {
            if builderResult.hasFile {
                builderResult.file = try File.builderWithPrototype(prototype:builderResult.file).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.file = value
            }
            builderResult.hasFile = true
            return self
        }
        @discardableResult
        public func clearFile() -> Voip.Builder {
            fileBuilder_ = nil
            builderResult.hasFile = false
            builderResult.file = nil
            return self
        }
        public var payload:Data {
            get {
                return builderResult.payload
            }
            set (value) {
                builderResult.hasPayload = true
                builderResult.payload = value
            }
        }
        public var hasPayload:Bool {
            get {
                return builderResult.hasPayload
            }
        }
        @discardableResult
        public func setPayload(_ value:Data) -> Voip.Builder {
            self.payload = value
            return self
        }
        @discardableResult
        public func clearPayload() -> Voip.Builder{
            builderResult.hasPayload = false
            builderResult.payload = nil
            return self
        }
        public var call:Call! {
            get {
                if callBuilder_ != nil {
                    builderResult.call = callBuilder_.getMessage()
                }
                return builderResult.call
            }
            set (value) {
                builderResult.hasCall = value != nil
                builderResult.call = value
            }
        }
        public var hasCall:Bool {
            get {
                return builderResult.hasCall
            }
        }
        fileprivate var callBuilder_:Call.Builder! {
            didSet {
                builderResult.hasCall = true
            }
        }
        public func getCallBuilder() -> Call.Builder {
            if callBuilder_ == nil {
                callBuilder_ = Call.Builder()
                builderResult.call = callBuilder_.getMessage()
                if call != nil {
                    try! callBuilder_.mergeFrom(other: call)
                }
            }
            return callBuilder_
        }
        @discardableResult
        public func setCall(_ value:Call!) -> Voip.Builder {
            self.call = value
            return self
        }
        @discardableResult
        public func mergeCall(value:Call) throws -> Voip.Builder {
            if builderResult.hasCall {
                builderResult.call = try Call.builderWithPrototype(prototype:builderResult.call).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.call = value
            }
            builderResult.hasCall = true
            return self
        }
        @discardableResult
        public func clearCall() -> Voip.Builder {
            callBuilder_ = nil
            builderResult.hasCall = false
            builderResult.call = nil
            return self
        }
        public var av:Av! {
            get {
                if avBuilder_ != nil {
                    builderResult.av = avBuilder_.getMessage()
                }
                return builderResult.av
            }
            set (value) {
                builderResult.hasAv = value != nil
                builderResult.av = value
            }
        }
        public var hasAv:Bool {
            get {
                return builderResult.hasAv
            }
        }
        fileprivate var avBuilder_:Av.Builder! {
            didSet {
                builderResult.hasAv = true
            }
        }
        public func getAvBuilder() -> Av.Builder {
            if avBuilder_ == nil {
                avBuilder_ = Av.Builder()
                builderResult.av = avBuilder_.getMessage()
                if av != nil {
                    try! avBuilder_.mergeFrom(other: av)
                }
            }
            return avBuilder_
        }
        @discardableResult
        public func setAv(_ value:Av!) -> Voip.Builder {
            self.av = value
            return self
        }
        @discardableResult
        public func mergeAv(value:Av) throws -> Voip.Builder {
            if builderResult.hasAv {
                builderResult.av = try Av.builderWithPrototype(prototype:builderResult.av).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.av = value
            }
            builderResult.hasAv = true
            return self
        }
        @discardableResult
        public func clearAv() -> Voip.Builder {
            avBuilder_ = nil
            builderResult.hasAv = false
            builderResult.av = nil
            return self
        }
        public var audioSession:Avsession! {
            get {
                if audioSessionBuilder_ != nil {
                    builderResult.audioSession = audioSessionBuilder_.getMessage()
                }
                return builderResult.audioSession
            }
            set (value) {
                builderResult.hasAudioSession = value != nil
                builderResult.audioSession = value
            }
        }
        public var hasAudioSession:Bool {
            get {
                return builderResult.hasAudioSession
            }
        }
        fileprivate var audioSessionBuilder_:Avsession.Builder! {
            didSet {
                builderResult.hasAudioSession = true
            }
        }
        public func getAudioSessionBuilder() -> Avsession.Builder {
            if audioSessionBuilder_ == nil {
                audioSessionBuilder_ = Avsession.Builder()
                builderResult.audioSession = audioSessionBuilder_.getMessage()
                if audioSession != nil {
                    try! audioSessionBuilder_.mergeFrom(other: audioSession)
                }
            }
            return audioSessionBuilder_
        }
        @discardableResult
        public func setAudioSession(_ value:Avsession!) -> Voip.Builder {
            self.audioSession = value
            return self
        }
        @discardableResult
        public func mergeAudioSession(value:Avsession) throws -> Voip.Builder {
            if builderResult.hasAudioSession {
                builderResult.audioSession = try Avsession.builderWithPrototype(prototype:builderResult.audioSession).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.audioSession = value
            }
            builderResult.hasAudioSession = true
            return self
        }
        @discardableResult
        public func clearAudioSession() -> Voip.Builder {
            audioSessionBuilder_ = nil
            builderResult.hasAudioSession = false
            builderResult.audioSession = nil
            return self
        }
        public var videoSession:Avsession! {
            get {
                if videoSessionBuilder_ != nil {
                    builderResult.videoSession = videoSessionBuilder_.getMessage()
                }
                return builderResult.videoSession
            }
            set (value) {
                builderResult.hasVideoSession = value != nil
                builderResult.videoSession = value
            }
        }
        public var hasVideoSession:Bool {
            get {
                return builderResult.hasVideoSession
            }
        }
        fileprivate var videoSessionBuilder_:Avsession.Builder! {
            didSet {
                builderResult.hasVideoSession = true
            }
        }
        public func getVideoSessionBuilder() -> Avsession.Builder {
            if videoSessionBuilder_ == nil {
                videoSessionBuilder_ = Avsession.Builder()
                builderResult.videoSession = videoSessionBuilder_.getMessage()
                if videoSession != nil {
                    try! videoSessionBuilder_.mergeFrom(other: videoSession)
                }
            }
            return videoSessionBuilder_
        }
        @discardableResult
        public func setVideoSession(_ value:Avsession!) -> Voip.Builder {
            self.videoSession = value
            return self
        }
        @discardableResult
        public func mergeVideoSession(value:Avsession) throws -> Voip.Builder {
            if builderResult.hasVideoSession {
                builderResult.videoSession = try Avsession.builderWithPrototype(prototype:builderResult.videoSession).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.videoSession = value
            }
            builderResult.hasVideoSession = true
            return self
        }
        @discardableResult
        public func clearVideoSession() -> Voip.Builder {
            videoSessionBuilder_ = nil
            builderResult.hasVideoSession = false
            builderResult.videoSession = nil
            return self
        }
        public var avQuality:Avquality! {
            get {
                if avQualityBuilder_ != nil {
                    builderResult.avQuality = avQualityBuilder_.getMessage()
                }
                return builderResult.avQuality
            }
            set (value) {
                builderResult.hasAvQuality = value != nil
                builderResult.avQuality = value
            }
        }
        public var hasAvQuality:Bool {
            get {
                return builderResult.hasAvQuality
            }
        }
        fileprivate var avQualityBuilder_:Avquality.Builder! {
            didSet {
                builderResult.hasAvQuality = true
            }
        }
        public func getAvQualityBuilder() -> Avquality.Builder {
            if avQualityBuilder_ == nil {
                avQualityBuilder_ = Avquality.Builder()
                builderResult.avQuality = avQualityBuilder_.getMessage()
                if avQuality != nil {
                    try! avQualityBuilder_.mergeFrom(other: avQuality)
                }
            }
            return avQualityBuilder_
        }
        @discardableResult
        public func setAvQuality(_ value:Avquality!) -> Voip.Builder {
            self.avQuality = value
            return self
        }
        @discardableResult
        public func mergeAvQuality(value:Avquality) throws -> Voip.Builder {
            if builderResult.hasAvQuality {
                builderResult.avQuality = try Avquality.builderWithPrototype(prototype:builderResult.avQuality).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.avQuality = value
            }
            builderResult.hasAvQuality = true
            return self
        }
        @discardableResult
        public func clearAvQuality() -> Voip.Builder {
            avQualityBuilder_ = nil
            builderResult.hasAvQuality = false
            builderResult.avQuality = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Voip.Builder {
            builderResult = Voip()
            return self
        }
        override public func clone() throws -> Voip.Builder {
            return try Voip.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Voip {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Voip {
            let returnMe:Voip = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Voip) throws -> Voip.Builder {
            if other == Voip() {
                return self
            }
            if other.hasVersion {
                version = other.version
            }
            if other.hasWhich {
                which = other.which
            }
            if !other.textStorage.isEmpty  {
                 builderResult.textStorage += other.textStorage
            }
            if (other.hasFile) {
                try mergeFile(value: other.file)
            }
            if other.hasPayload {
                payload = other.payload
            }
            if (other.hasCall) {
                try mergeCall(value: other.call)
            }
            if (other.hasAv) {
                try mergeAv(value: other.av)
            }
            if (other.hasAudioSession) {
                try mergeAudioSession(value: other.audioSession)
            }
            if (other.hasVideoSession) {
                try mergeVideoSession(value: other.videoSession)
            }
            if (other.hasAvQuality) {
                try mergeAvQuality(value: other.avQuality)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Voip.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Voip.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    version = try codedInputStream.readUInt32()

                case 96:
                    let valueIntwhich = try codedInputStream.readEnum()
                    if let enumswhich = Voip.Which(rawValue:valueIntwhich){
                        which = enumswhich
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 12, value:Int64(valueIntwhich))
                    }

                case 146:
                    let subBuilder:Avquality.Builder = Avquality.Builder()
                    if hasAvQuality {
                        try subBuilder.mergeFrom(other: avQuality)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    avQuality = subBuilder.buildPartial()

                case 810:
                    let subBuilder = Text.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    textStorage.append(subBuilder.buildPartial())

                case 818:
                    let subBuilder:File.Builder = File.Builder()
                    if hasFile {
                        try subBuilder.mergeFrom(other: file)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    file = subBuilder.buildPartial()

                case 826:
                    payload = try codedInputStream.readData()

                case 834:
                    let subBuilder:Call.Builder = Call.Builder()
                    if hasCall {
                        try subBuilder.mergeFrom(other: call)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    call = subBuilder.buildPartial()

                case 842:
                    let subBuilder:Av.Builder = Av.Builder()
                    if hasAv {
                        try subBuilder.mergeFrom(other: av)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    av = subBuilder.buildPartial()

                case 850:
                    let subBuilder:Avsession.Builder = Avsession.Builder()
                    if hasAudioSession {
                        try subBuilder.mergeFrom(other: audioSession)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    audioSession = subBuilder.buildPartial()

                case 858:
                    let subBuilder:Avsession.Builder = Avsession.Builder()
                    if hasVideoSession {
                        try subBuilder.mergeFrom(other: videoSession)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    videoSession = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Voip.Builder {
            let resultDecodedBuilder = Voip.Builder()
            if let jsonValueVersion = jsonMap["version"] as? UInt {
                resultDecodedBuilder.version = UInt32(jsonValueVersion)
            } else if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = UInt32(jsonValueVersion)!
            }
            if let jsonValueWhich = jsonMap["which"] as? String {
                resultDecodedBuilder.which = try Voip.Which.fromString(jsonValueWhich)
            }
            if let jsonValueTextStorage = jsonMap["textStorage"] as? Array<Dictionary<String,Any>> {
                var jsonArrayTextStorage:Array<Text> = []
                for oneValueTextStorage in jsonValueTextStorage {
                    let messageFromStringTextStorage = try Text.Builder.decodeToBuilder(jsonMap:oneValueTextStorage).build()

                    jsonArrayTextStorage.append(messageFromStringTextStorage)
                }
                resultDecodedBuilder.textStorage = jsonArrayTextStorage
            }
            if let jsonValueFile = jsonMap["file"] as? Dictionary<String,Any> {
                resultDecodedBuilder.file = try File.Builder.decodeToBuilder(jsonMap:jsonValueFile).build()

            }
            if let jsonValuePayload = jsonMap["payload"] as? String {
                resultDecodedBuilder.payload = Data(base64Encoded:jsonValuePayload, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            if let jsonValueCall = jsonMap["call"] as? Dictionary<String,Any> {
                resultDecodedBuilder.call = try Call.Builder.decodeToBuilder(jsonMap:jsonValueCall).build()

            }
            if let jsonValueAv = jsonMap["av"] as? Dictionary<String,Any> {
                resultDecodedBuilder.av = try Av.Builder.decodeToBuilder(jsonMap:jsonValueAv).build()

            }
            if let jsonValueAudioSession = jsonMap["audioSession"] as? Dictionary<String,Any> {
                resultDecodedBuilder.audioSession = try Avsession.Builder.decodeToBuilder(jsonMap:jsonValueAudioSession).build()

            }
            if let jsonValueVideoSession = jsonMap["videoSession"] as? Dictionary<String,Any> {
                resultDecodedBuilder.videoSession = try Avsession.Builder.decodeToBuilder(jsonMap:jsonValueVideoSession).build()

            }
            if let jsonValueAvQuality = jsonMap["avQuality"] as? Dictionary<String,Any> {
                resultDecodedBuilder.avQuality = try Avquality.Builder.decodeToBuilder(jsonMap:jsonValueAvQuality).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Voip.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Voip.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension Text: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Text> {
        var mergedArray = Array<Text>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Text? {
        return try Text.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Text {
        return try Text.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Text {
        return try Text.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Text {
        return try Text.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Text {
        return try Text.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Text {
        return try Text.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Text {
        return try Text.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "from": return self.from
        case "to": return self.to
        case "body": return self.body
        default: return nil
        }
    }
}
extension Text.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Text
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "from": return self.from
            case "to": return self.to
            case "body": return self.body
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "from":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.from = newSubscriptValue
            case "to":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.to = newSubscriptValue
            case "body":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.body = newSubscriptValue
            default: return
            }
        }
    }
}
extension File: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<File> {
        var mergedArray = Array<File>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> File? {
        return try File.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> File {
        return try File.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> File {
        return try File.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> File {
        return try File.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> File {
        return try File.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> File {
        return try File.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> File {
        return try File.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sequence": return self.sequence
        case "totalSize": return self.totalSize
        case "body": return self.body
        default: return nil
        }
    }
}
extension File.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = File
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sequence": return self.sequence
            case "totalSize": return self.totalSize
            case "body": return self.body
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sequence":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.sequence = newSubscriptValue
            case "totalSize":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.totalSize = newSubscriptValue
            case "body":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.body = newSubscriptValue
            default: return
            }
        }
    }
}
extension Call: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Call> {
        var mergedArray = Array<Call>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Call? {
        return try Call.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Call {
        return try Call.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Call {
        return try Call.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Call {
        return try Call.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Call {
        return try Call.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Call {
        return try Call.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Call {
        return try Call.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "to": return self.to
        case "from": return self.from
        case "audio": return self.audio
        case "video": return self.video
        default: return nil
        }
    }
}
extension Call.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Call
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "to": return self.to
            case "from": return self.from
            case "audio": return self.audio
            case "video": return self.video
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "to":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.to = newSubscriptValue
            case "from":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.from = newSubscriptValue
            case "audio":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.audio = newSubscriptValue
            case "video":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.video = newSubscriptValue
            default: return
            }
        }
    }
}
extension Time: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Time> {
        var mergedArray = Array<Time>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Time? {
        return try Time.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Time {
        return try Time.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Time {
        return try Time.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Time {
        return try Time.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Time {
        return try Time.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Time {
        return try Time.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Time {
        return try Time.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        case "scale": return self.scale
        case "flags": return self.flags
        case "epoch": return self.epoch
        default: return nil
        }
    }
}
extension Time.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Time
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            case "scale": return self.scale
            case "flags": return self.flags
            case "epoch": return self.epoch
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.value = newSubscriptValue
            case "scale":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.scale = newSubscriptValue
            case "flags":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.flags = newSubscriptValue
            case "epoch":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.epoch = newSubscriptValue
            default: return
            }
        }
    }
}
extension Timestamp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Timestamp> {
        var mergedArray = Array<Timestamp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Timestamp? {
        return try Timestamp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "duration": return self.duration
        case "presentation": return self.presentation
        default: return nil
        }
    }
}
extension Timestamp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Timestamp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "duration": return self.duration
            case "presentation": return self.presentation
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "duration":
                guard let newSubscriptValue = newSubscriptValue as? Time else {
                    return
                }
                self.duration = newSubscriptValue
            case "presentation":
                guard let newSubscriptValue = newSubscriptValue as? Time else {
                    return
                }
                self.presentation = newSubscriptValue
            default: return
            }
        }
    }
}
extension Image: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Image> {
        var mergedArray = Array<Image>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Image? {
        return try Image.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Image {
        return try Image.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Image {
        return try Image.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Image {
        return try Image.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Image {
        return try Image.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Image {
        return try Image.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Image {
        return try Image.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "width": return self.width
        case "height": return self.height
        case "format": return self.format
        case "attachments": return self.attachments
        case "data": return self.data
        default: return nil
        }
    }
}
extension Image.AttachmentsEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Image.AttachmentsEntry> {
        var mergedArray = Array<Image.AttachmentsEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Image.AttachmentsEntry? {
        return try Image.AttachmentsEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Image.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Image
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "width": return self.width
            case "height": return self.height
            case "format": return self.format
            case "attachments": return self.attachments
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "width":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.width = newSubscriptValue
            case "height":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.height = newSubscriptValue
            case "format":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.format = newSubscriptValue
            case "attachments":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.attachments = newSubscriptValue
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Image.AttachmentsEntry.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Image.AttachmentsEntry
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension FormatDescription: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<FormatDescription> {
        var mergedArray = Array<FormatDescription>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> FormatDescription? {
        return try FormatDescription.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "mediaType": return self.mediaType
        case "mediaSubtype": return self.mediaSubtype
        case "extensions": return self.extensions
        default: return nil
        }
    }
}
extension FormatDescription.ExtensionsEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<FormatDescription.ExtensionsEntry> {
        var mergedArray = Array<FormatDescription.ExtensionsEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> FormatDescription.ExtensionsEntry? {
        return try FormatDescription.ExtensionsEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension FormatDescription.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = FormatDescription
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "mediaType": return self.mediaType
            case "mediaSubtype": return self.mediaSubtype
            case "extensions": return self.extensions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "mediaType":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.mediaType = newSubscriptValue
            case "mediaSubtype":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.mediaSubtype = newSubscriptValue
            case "extensions":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.extensions = newSubscriptValue
            default: return
            }
        }
    }
}
extension FormatDescription.ExtensionsEntry.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = FormatDescription.ExtensionsEntry
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension VideoSample: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<VideoSample> {
        var mergedArray = Array<VideoSample>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> VideoSample? {
        return try VideoSample.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "image": return self.image
        default: return nil
        }
    }
}
extension VideoSample.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = VideoSample
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "image": return self.image
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "image":
                guard let newSubscriptValue = newSubscriptValue as? Image else {
                    return
                }
                self.image = newSubscriptValue
            default: return
            }
        }
    }
}
extension AudioSample: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<AudioSample> {
        var mergedArray = Array<AudioSample>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> AudioSample? {
        return try AudioSample.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "image": return self.image
        default: return nil
        }
    }
}
extension AudioSample.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = AudioSample
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "image": return self.image
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "image":
                guard let newSubscriptValue = newSubscriptValue as? Image else {
                    return
                }
                self.image = newSubscriptValue
            default: return
            }
        }
    }
}
extension Av: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Av> {
        var mergedArray = Array<Av>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Av? {
        return try Av.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Av {
        return try Av.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Av {
        return try Av.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Av {
        return try Av.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Av {
        return try Av.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Av {
        return try Av.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Av {
        return try Av.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "video": return self.video
        case "audio": return self.audio
        default: return nil
        }
    }
}
extension Av.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Av
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "video": return self.video
            case "audio": return self.audio
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "video":
                guard let newSubscriptValue = newSubscriptValue as? VideoSample else {
                    return
                }
                self.video = newSubscriptValue
            case "audio":
                guard let newSubscriptValue = newSubscriptValue as? AudioSample else {
                    return
                }
                self.audio = newSubscriptValue
            default: return
            }
        }
    }
}
extension Avsession: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Avsession> {
        var mergedArray = Array<Avsession>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Avsession? {
        return try Avsession.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sid": return self.sid
        case "gid": return self.gid
        case "active": return self.active
        case "data": return self.data
        default: return nil
        }
    }
}
extension Avsession.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Avsession
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sid": return self.sid
            case "gid": return self.gid
            case "active": return self.active
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sid = newSubscriptValue
            case "gid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.gid = newSubscriptValue
            case "active":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.active = newSubscriptValue
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Avquality: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Avquality> {
        var mergedArray = Array<Avquality>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Avquality? {
        return try Avquality.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "diff": return self.diff
        default: return nil
        }
    }
}
extension Avquality.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Avquality
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "diff": return self.diff
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "diff":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.diff = newSubscriptValue
            default: return
            }
        }
    }
}
extension Voip: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Voip> {
        var mergedArray = Array<Voip>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Voip? {
        return try Voip.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Voip {
        return try Voip.Builder().mergeFrom(data: data, extensionRegistry:VoipRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Voip {
        return try Voip.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Voip {
        return try Voip.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Voip {
        return try Voip.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Voip {
        return try Voip.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Voip {
        return try Voip.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "version": return self.version
        case "which": return self.which
        case "textStorage": return self.textStorage
        case "file": return self.file
        case "payload": return self.payload
        case "call": return self.call
        case "av": return self.av
        case "audioSession": return self.audioSession
        case "videoSession": return self.videoSession
        case "avQuality": return self.avQuality
        default: return nil
        }
    }
}
extension Voip.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Voip
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "version": return self.version
            case "which": return self.which
            case "textStorage": return self.textStorage
            case "file": return self.file
            case "payload": return self.payload
            case "call": return self.call
            case "av": return self.av
            case "audioSession": return self.audioSession
            case "videoSession": return self.videoSession
            case "avQuality": return self.avQuality
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.version = newSubscriptValue
            case "which":
                guard let newSubscriptValue = newSubscriptValue as? Voip.Which else {
                    return
                }
                self.which = newSubscriptValue
            case "textStorage":
                guard let newSubscriptValue = newSubscriptValue as? Array<Text> else {
                    return
                }
                self.textStorage = newSubscriptValue
            case "file":
                guard let newSubscriptValue = newSubscriptValue as? File else {
                    return
                }
                self.file = newSubscriptValue
            case "payload":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.payload = newSubscriptValue
            case "call":
                guard let newSubscriptValue = newSubscriptValue as? Call else {
                    return
                }
                self.call = newSubscriptValue
            case "av":
                guard let newSubscriptValue = newSubscriptValue as? Av else {
                    return
                }
                self.av = newSubscriptValue
            case "audioSession":
                guard let newSubscriptValue = newSubscriptValue as? Avsession else {
                    return
                }
                self.audioSession = newSubscriptValue
            case "videoSession":
                guard let newSubscriptValue = newSubscriptValue as? Avsession else {
                    return
                }
                self.videoSession = newSubscriptValue
            case "avQuality":
                guard let newSubscriptValue = newSubscriptValue as? Avquality else {
                    return
                }
                self.avQuality = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
